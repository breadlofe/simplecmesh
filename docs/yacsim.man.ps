%!PS-Adobe-3.0
%%Title: (YACSIM Reference Manual)
%%Creator: (Microsoft Word: LaserWriter 8.0 8.0)
%%CreationDate: (1:40 PM Thursday, July 1, 1993)
%%For: ()
%%Pages: 58
%%DocumentFonts: Helvetica-Bold Helvetica-BoldOblique Times-BoldItalic Times-Roman Symbol Times-Bold Times-Italic
%%DocumentNeededFonts: Helvetica-Bold Helvetica-BoldOblique Times-BoldItalic Times-Roman Symbol Times-Bold Times-Italic
%%DocumentSuppliedFonts:
%%DocumentData: Clean7Bit
%%PageOrder: Ascend
%%Orientation: Portrait
%ADO_PaperArea: -31 -31 761 581
%ADO_ImageableArea: 0 0 730 552
%%EndComments
/md 211 dict def md begin
/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if
%%BeginFile: adobe_psp_basic
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/bd{bind def}bind def
/xdf{exch def}bd
/xs{exch store}bd
/ld{load def}bd
/Z{0 def}bd
/T/true
/F/false
/:L/lineto
/lw/setlinewidth
/:M/moveto
/rl/rlineto
/rm/rmoveto
/:C/curveto
/:T/translate
/:K/closepath
/:mf/makefont
/gS/gsave
/gR/grestore
/np/newpath
14{ld}repeat
/$m matrix def
/av 80 def
/por true def
/normland false def
/psb-nosave{}bd
/pse-nosave{}bd
/us Z
/psb{/us save store}bd
/pse{us restore}bd
/level2
/languagelevel where
{
pop languagelevel 2 ge
}{
false
}ifelse
def
/featurecleanup
{
stopped
cleartomark
countdictstack exch sub dup 0 gt
{
{end}repeat
}{
pop
}ifelse
}bd
/noload Z
/startnoload
{
{/noload save store}if
}bd
/endnoload
{
{noload restore}if
}bd
level2 startnoload
/setjob
{
statusdict/jobname 3 -1 roll put
}bd
/setcopies
{
userdict/#copies 3 -1 roll put
}bd
level2 endnoload level2 not startnoload
/setjob
{
1 dict begin/JobName xdf currentdict end setuserparams
}bd
/setcopies
{
1 dict begin/NumCopies xdf currentdict end setpagedevice
}bd
level2 not endnoload
/pm Z
/mT Z
/sD Z
/realshowpage Z
/initializepage
{
/pm save store mT concat
}bd
/endp
{
pm restore showpage
}def
/$c/DeviceRGB def
/rectclip where
{
pop/rC/rectclip ld
}{
/rC
{
np 4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
clip np
}bd
}ifelse
/rectfill where
{
pop/rF/rectfill ld
}{
/rF
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
fill
gR
}bd
}ifelse
/rectstroke where
{
pop/rS/rectstroke ld
}{
/rS
{
gS
np
4 2 roll
:M
1 index 0 rl
0 exch rl
neg 0 rl
:K
stroke
gR
}bd
}ifelse
%%EndFile
%%BeginFile: adobe_psp_colorspace_level1
%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved.
/G/setgray ld
/:F/setrgbcolor ld
%%EndFile
%%BeginFile: adobe_psp_uniform_graphics
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/@a
{
np :M 0 rl :L 0 exch rl 0 rl :L fill
}bd
/@b
{
np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill
}bd
/arct where
{
pop
}{
/arct
{
arcto pop pop pop pop
}bd
}ifelse
/x1 Z
/x2 Z
/y1 Z
/y2 Z
/rad Z
/@q
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
fill
}bd
/@s
{
/rad xs
/y2 xs
/x2 xs
/y1 xs
/x1 xs
np
x2 x1 add 2 div y1 :M
x2 y1 x2 y2 rad arct
x2 y2 x1 y2 rad arct
x1 y2 x1 y1 rad arct
x1 y1 x2 y1 rad arct
:K
stroke
}bd
/@i
{
np 0 360 arc fill
}bd
/@j
{
gS
np
:T
scale
0 0 .5 0 360 arc
fill
gR
}bd
/@e
{
np
0 360 arc
:K
stroke
}bd
/@f
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 0 360 arc
:K
$m setmatrix
stroke
}bd
/@k
{
gS
np
:T
0 0 :M
0 0 5 2 roll
arc fill
gR
}bd
/@l
{
gS
np
:T
0 0 :M
scale
0 0 .5 5 -2 roll arc
fill
gR
}bd
/@m
{
np
arc
stroke
}bd
/@n
{
np
$m currentmatrix
pop
:T
scale
0 0 .5 5 -2 roll arc
$m setmatrix
stroke
}bd
%%EndFile
%%BeginFile: adobe_psp_customps
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/$t Z
/$p Z
/$s Z
/$o 1. def
/2state? false def
/ps Z
level2 startnoload
/pushcolor/currentrgbcolor ld
/popcolor/setrgbcolor ld
/setcmykcolor where
{
pop/currentcmykcolor where
{
pop/pushcolor/currentcmykcolor ld
/popcolor/setcmykcolor ld
}if
}if
level2 endnoload level2 not startnoload
/pushcolor
{
currentcolorspace $c eq
{
currentcolor currentcolorspace true
}{
currentcmykcolor false
}ifelse
}bd
/popcolor
{
{
setcolorspace setcolor
}{
setcmykcolor
}ifelse
}bd
level2 not endnoload
/pushstatic
{
ps
2state?
$o
$t
$p
$s
}bd
/popstatic
{
/$s xs
/$p xs
/$t xs
/$o xs
/2state? xs
/ps xs
}bd
/pushgstate
{
save errordict/nocurrentpoint{pop 0 0}put
currentpoint
3 -1 roll restore
pushcolor
currentlinewidth
currentlinecap
currentlinejoin
currentdash exch aload length
np clippath pathbbox
$m currentmatrix aload pop
}bd
/popgstate
{
$m astore setmatrix
2 index sub exch
3 index sub exch
rC
array astore exch setdash
setlinejoin
setlinecap
lw
popcolor
np :M
}bd
/bu
{
pushgstate
gR
pushgstate
2state?
{
gR
pushgstate
}if
pushstatic
pm restore
mT concat
}bd
/bn
{
/pm save store
popstatic
popgstate
gS
popgstate
2state?
{
gS
popgstate
}if
}bd
/cpat{pop 64 div G 8{pop}repeat}bd
%%EndFile
%%BeginFile: adobe_psp_basic_text
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/S/show ld
/A{
0.0 exch ashow
}bd
/R{
0.0 exch 32 exch widthshow
}bd
/W{
0.0 3 1 roll widthshow
}bd
/J{
0.0 32 4 2 roll 0.0 exch awidthshow
}bd
/V{
0.0 4 1 roll 0.0 exch awidthshow
}bd
/fcflg true def
/fc{
fcflg{
vmstatus exch sub 50000 lt{
(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store
}if pop
}if
}bd
/$f[1 0 0 -1 0 0]def
/:ff{$f :mf}bd
/MacEncoding StandardEncoding 256 array copy def
MacEncoding 39/quotesingle put
MacEncoding 96/grave put
/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute
/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave
/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute
/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis
/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls
/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash
/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation
/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash
/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft
/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe
/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge
/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl
/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand
/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave
/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde
/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caron
MacEncoding 128 128 getinterval astore pop
level2 startnoload
/copyfontdict
{
findfont dup length dict
begin
{
1 index/FID ne{def}{pop pop}ifelse
}forall
}bd
level2 endnoload level2 not startnoload
/copyfontdict
{
findfont dup length dict
copy
begin
}bd
level2 not endnoload
md/fontname known not{
/fontname/customfont def
}if
/Encoding Z
/:mre
{
copyfontdict
/Encoding MacEncoding def
fontname currentdict
end
definefont :ff def
}bd
/:bsr
{
copyfontdict
/Encoding Encoding 256 array copy def
Encoding dup
}bd
/pd{put dup}bd
/:esr
{
pop pop
fontname currentdict
end
definefont :ff def
}bd
/scf
{
scalefont def
}bd
/scf-non
{
$m scale :mf setfont
}bd
/ps Z
/fz{/ps xs}bd
/sf/setfont ld
/cF/currentfont ld
/mbf
{
/makeblendedfont where
{
pop
makeblendedfont
/ABlend exch definefont
}{
pop
}ifelse
def
}def
%%EndFile
%%BeginFile: adobe_psp_derived_styles
%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved.
/wi
version(23.0)eq
{
{
gS 0 0 0 0 rC stringwidth gR
}bind
}{
/stringwidth load
}ifelse
def
/$o 1. def
/gl{$o G}bd
/ms{:M S}bd
/condensedmtx[.82 0 0 1 0 0]def
/:mc
{
condensedmtx :mf def
}bd
/extendedmtx[1.18 0 0 1 0 0]def
/:me
{
extendedmtx :mf def
}bd
/basefont Z
/basefonto Z
/dxa Z
/dxb Z
/dxc Z
/dxd Z
/dsdx2 Z
/bfproc Z
/:fbase
{
dup/FontType get 0 eq{
dup length dict begin
dup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall
/FDepVector exch/FDepVector get[exch/:fbase load forall]def
}/bfproc load ifelse
/customfont currentdict end definefont
}bd
/:mo
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
basefont setfont
( )dup 0 4 -1 roll put
dup wi
setcharwidth
0 0 :M
gS
gl
dup show
gR
basefonto setfont
show
end
}def
}store :fbase
}bd
/:mso
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxa 1 ps div def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxa add exch
}if
setcharwidth
dup 0 0 ms
dup dxa 0 ms
dup dxa dxa ms
dup 0 dxa ms
gl
dxa 2. div dup ms
end
end
}def
}store :fbase
}bd
/:ms
{
/bfproc{
dup dup length 2 add dict
begin
{
1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse
}forall
/PaintType 2 def
/StrokeWidth .012 0 FontMatrix idtransform pop def
/customfont currentdict
end
definefont
8 dict begin
/basefonto xdf
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxb .05 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dxb add
}if
exch setcharwidth
dup dxb .01 add 0 ms
0 dxb :T
gS
gl
dup 0 0 ms
gR
basefonto setfont
0 0 ms
end
end
}def
}store :fbase
}bd
/:mss
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxc 1 ps div def
/dsdx2 .05 dxc 2 div add def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
exch dup 0 ne
{
dsdx2 add
}if
exch setcharwidth
dup dsdx2 .01 add 0 ms
0 .05 dxc 2 div sub :T
dup 0 0 ms
dup dxc 0 ms
dup dxc dxc ms
dup 0 dxc ms
gl
dxc 2 div dup ms
end
end
}def
}store :fbase
}bd
/:msb
{
/bfproc{
7 dict begin
/basefont xdf
/FontType 3 def
/FontMatrix[1 0 0 1 0 0]def
/FontBBox[0 0 1 1]def
/Encoding StandardEncoding def
/BuildChar
{
exch begin
sD begin
/dxd .03 def
basefont setfont
( )dup 0 4 -1 roll put
dup wi
1 index 0 ne
{
exch dxd add exch
}if
setcharwidth
dup 0 0 ms
dup dxd 0 ms
dup dxd dxd ms
0 dxd ms
end
end
}def
}store :fbase
}bd
/italicmtx[1 0 -.212557 1 0 0]def
/:mi
{
italicmtx :mf def
}bd
/:v
{
[exch dup/FontMatrix get exch
dup/FontInfo known
{
/FontInfo get
dup/UnderlinePosition known
{
dup/UnderlinePosition get
2 index 0
3 1 roll
transform
exch pop
}{
.1
}ifelse
3 1 roll
dup/UnderlineThickness known
{
/UnderlineThickness get
exch 0 3 1 roll
transform
exch pop
abs
}{
pop pop .067
}ifelse
}{
pop pop .1 .067
}ifelse
]
}bd
/$t Z
/$p Z
/$s Z
/:p
{
aload pop
2 index mul/$t xs
1 index mul/$p xs
.012 mul/$s xs
}bd
/:m
{gS
0 $p rm
$t lw
0 rl stroke
gR
}bd
/:n
{
gS
0 $p rm
$t lw
0 rl
gS
gl
stroke
gR
strokepath
$s lw
/setstrokeadjust where{pop
currentstrokeadjust true setstrokeadjust stroke setstrokeadjust
}{
stroke
}ifelse
gR
}bd
/:o
{gS
0 $p rm
$t 2 div dup rm
$t lw
dup 0 rl
stroke
gR
:n
}bd
%%EndFile
/currentpacking where {pop sc_oldpacking setpacking}if
end		% md
%%EndProlog
%%BeginSetup
md begin
countdictstack
[
{%stopped
%%BeginFeature: *ManualFeed False
statusdict /manualfeed false put
%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *InputSlot Cassette

%%EndFeature
}featurecleanup
countdictstack
[
{%stopped
%%BeginFeature: *PageRegion LetterSmall
lettersmall
%%EndFeature
}featurecleanup
()setjob
/pT[1 0 0 -1 31 761]def/mT[1 0 0 -1 31 761]def
/sD 16 dict def
300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse
%%IncludeFont: Helvetica-Bold
%%IncludeFont: Helvetica-BoldOblique
%%IncludeFont: Times-BoldItalic
%%IncludeFont: Times-Roman
%%IncludeFont: Symbol
%%IncludeFont: Times-Bold
%%IncludeFont: Times-Italic
/f0_1/Helvetica-Bold :mre
/f0_24 f0_1 24 scf
/f0_18 f0_1 18 scf
/f0_14 f0_1 14 scf
/f4_1/Helvetica-BoldOblique :mre
/f4_18 f4_1 18 scf
/f4_12 f4_1 12 scf
/f5_1/Times-BoldItalic :mre
/f5_12 f5_1 12 scf
/f6_1 f5_1 :ff :ms :ff def
/f6_48 f6_1 48 scf
/f7_1/Times-Roman :mre
/f7_12 f7_1 12 scf
/f7_10 f7_1 10 scf
/f7_9 f7_1 9 scf
/f8_1/Symbol :bsr
240/apple pd
:esr /f8_12 f8_1 12 scf
/f8_10 f8_1 10 scf
/f8_9 f8_1 9 scf
/f9_1/Times-Bold :mre
/f9_18 f9_1 18 scf
/f9_12 f9_1 12 scf
/f10_1 f8_1 def
/f10_12 f10_1 12 scf
/f11_1/Times-Italic :mre
/f11_14 f11_1 14 scf
/f11_12 f11_1 12 scf
/f11_10 f11_1 10 scf
/f11_9 f11_1 9 scf
/f12_1 f8_1 :mi
/f12_12 f12_1 12 scf
/f13_1 f7_1 :v def
/Courier findfont[10 0 0 -10 0 0]:mf setfont
%%EndSetup
%%Page: 1 1
%%BeginPageSetup
initializepage
(; page: 1 of 58)setjob
%%EndPageSetup
gS 0 0 552 730 rC
199 67 :M
f0_18 sf
5.833 .583(RICE UNIVERSITY)J
77 97 :M
f4_18 sf
1.448 .145(Electrical & Computer Engineering Department)J
172 258 :M
f6_48 sf
/$o 1 def
5.646(YACSIM)A
172 296 :M
f0_24 sf
7.064 .706(Reference Manual)J
243 318 :M
f0_14 sf
3.157 .316(Version 2.1)J
232 341 :M
f0_18 sf
3.145 .314(March 1993)J
217 482 :M
.913 .091(J. Robert Jump)J
218 507 :M
f7_12 sf
-.065(ECE Dept., Rice University)A
247 519 :M
.519 .052(P.O. Box 1892)J
221 531 :M
.329 .033(Houston, TX 77251-1892)J
237 543 :M
-.158(email:  jrj@rice.edu)A
203 555 :M
(Phone:  \(713\) 527-8101 ext. 3576)S
131 651 :M
f7_10 sf
-.006(This manual describes a simulator that has not been thoroughly tested and may)A
131 662 :M
.29 .029(contain bugs.  Suggestions, criticisms, questions, or reports of any problems,)J
131 673 :M
-.028(errors, or bugs with the manual or the simulator are welcome and encouraged.)A
131 684 :M
.088 .009(Please send them to J. R. Jump at the above address.)J
endp
%%Page: 2 2
%%BeginPageSetup
initializepage
(; page: 2 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
312 753 :M
f7_12 sf
-.668(ii)A
193 167 :M
f0_14 sf
2.312 .231(Copyright 1993 by Rice University)J
258 181 :M
3.819 .382(Houston, Texas)J
244 208 :M
2.31 .231(All Rights Reserved)J
126 256 :M
f7_12 sf
2.822 .282(Permission to use, copy, modify, and distribute this software and its)J
126 268 :M
.824 .082(documentation for any research purpose and without fee is hereby granted,)J
126 280 :M
-.049(provided that the above copyright notice appear in all copies and that both that)A
126 292 :M
4.505 .45(copyright notice and this permission notice appear in supporting)J
126 304 :M
-.094(documentation, and that the name of Rice University not be used in advertising)A
126 316 :M
1.415 .142(or in publicity pertaining to distribution of the software without specific,)J
126 328 :M
-.079(written prior permission. The inclusion of this software or its documentation in)A
126 340 :M
2.956 .296(any commercial product without specific, written prior permission is)J
126 352 :M
-.032(prohibited.)A
126 376 :M
-.066(Rice University disclaims all warranties with regard to this software, including)A
126 388 :M
.447 .045(all implied warranties of merchantability and fitness.  In no event shall Rice)J
126 400 :M
.098 .01(University be liable for any special, indirect or consequential damages or any)J
126 412 :M
.195 .019(damages whatsoever resulting from loss of use, data or profits, whether in an)J
126 424 :M
1.18 .118(action of contract, negligence or other tortious action, arising out of or in)J
126 436 :M
-.063(connection with this use or performance of this software.)A
289 534 :M
f0_14 sf
.63(Credits)A
126 558 :M
f7_12 sf
.308 .031(YACSIM is derived from XSIM, a C++ discrete event simulator written by J.)J
126 570 :M
-.03(R. Jump.  XSIM was influenced by, and is a significant enhancement of CSIM,)A
126 582 :M
-.003(a discrete event simulator developed at Rice University by Richard Covington.)A
126 594 :M
1.533 .153(J. B. Sinclair wrote the YACSIM random number generator code and the)J
126 606 :M
1.01 .101(machine dependent code for context switching on the IBM RISC/SYSTEM)J
126 618 :M
-.04(6000 and the SPARC architectures.  J. R. Jump wrote the other YACSIM code.)A
endp
%%Page: 3 3
%%BeginPageSetup
initializepage
(; page: 3 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
310 753 :M
f7_12 sf
-.501(iii)A
214 86 :M
f9_18 sf
2.215 .222(TABLE OF CONTENTS)J
108 129 :M
f7_12 sf
-.123(Table of Contents)A
531 129 :M
-.501(iii)A
108 153 :M
-.021(1.  Introduction)A
534 153 :M
(1)S
135 165 :M
-.057(1.1.  Simulation Objects)A
534 165 :M
(1)S
135 177 :M
-.034(1.2.  Using Simulation Objects)A
534 177 :M
(2)S
135 189 :M
-.039(1.3.  The functions main\(\) and UserMain\(\))A
534 189 :M
(3)S
135 201 :M
-.048(1.4.  Command Line Arguments)A
534 201 :M
(3)S
135 213 :M
-.071(1.5.  Compiling YACSIM Simulations)A
534 213 :M
(4)S
108 237 :M
-.127(2.  Activities)A
534 237 :M
(5)S
135 249 :M
-.116(2.1.  Operations Common to All Activities)A
534 249 :M
(5)S
135 261 :M
.693 .069(2.2.  Processes)J
528 261 :M
(10)S
135 273 :M
.433 .043(2.3.  Events)J
528 273 :M
(14)S
108 297 :M
(3.  Queues)S
528 297 :M
(19)S
135 309 :M
.388 .039(3.1.  Semaphores)J
528 309 :M
(19)S
135 321 :M
.413 .041(3.2.  Barriers)J
528 321 :M
(21)S
135 333 :M
.667 .067(3.3.  Flags)J
528 333 :M
(22)S
135 345 :M
-.056(3.4.  Conditions and State Variables)A
528 345 :M
(24)S
135 357 :M
.497 .05(3.5.  Resources)J
528 357 :M
(28)S
135 369 :M
-.031(3.6.  Queue Statistics)A
528 369 :M
(32)S
108 393 :M
-.043(4.  Statistics Records & Random Numbers)A
528 393 :M
(33)S
135 405 :M
-.038(4.1.  Point and Interval Statistics Records)A
528 405 :M
(33)S
135 417 :M
-.01(4.2.  Random Number Generation)A
528 417 :M
(37)S
108 441 :M
-.11(5.  The Simulation Driver)A
528 441 :M
(39)S
135 453 :M
(5.1.  The Driver)S
528 453 :M
(39)S
135 465 :M
-.016(5.2.  The Event List)A
528 465 :M
(40)S
108 489 :M
-.027(6.  Debugging)A
528 489 :M
(43)S
135 501 :M
.073 .007(6.1.  Warning Messages)J
528 501 :M
(43)S
135 513 :M
.213 .021(6.2.  Error Messages)J
528 513 :M
(45)S
135 525 :M
.216 .022(6.3.  Tracing)J
528 525 :M
(48)S
108 549 :M
-.122(Appendix 1:  Defined Symbols)A
528 549 :M
(50)S
108 573 :M
-.123(Appendix 2: Summary of Operations)A
528 573 :M
(51)S
108 597 :M
-.195(Appendix 3:  Alphabetical Operation List)A
528 597 :M
(54)S
endp
%%Page: 4 4
%%BeginPageSetup
initializepage
(; page: 4 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
532 739 :M
f4_12 sf
(1)S
226 86 :M
f9_18 sf
3.005 .3(1.  INTRODUCTION)J
90 129 :M
f7_12 sf
-.114(YACSIM is a discrete-event simulation language based on the C programming language.  It is)A
90 141 :M
-.124(implemented as a collection of data structures and a library of C subroutines that can be linked)A
90 153 :M
-.099(with any program written in C.  Extending an existing language by adding discrete-event)A
90 165 :M
-.095(simulation routines is a common approach.  The main advantages of this over designing a)A
90 177 :M
-.129(completely new language are that the user can write most of the code of a simulation in a well-)A
90 189 :M
-.044(known and widely-used language, and a new compiler is not required.  A user who knows the)A
90 201 :M
-.099(base language only needs to learn how to use the simulation library routines in order to write)A
90 213 :M
-.051(simulation programs.)A
90 237 :M
-.106(There are at least two other simulation languages based on the C programming language, both)A
90 249 :M
-.093(called CSIM.  One was developed at Rice University as part of a parallel processing testbed,)A
90 261 :M
-.105(and the other was developed at MCC in Austin, TX.  YACSIM is Yet Another CSIM that has)A
90 273 :M
-.095(features in common with both of these.  It is more closely related to the Rice CSIM and was)A
90 285 :M
-.12(developed to replace that language for the parallel processing performance work at Rice.)A
90 309 :M
-.115(This manual describes the simulation routines in the YACSIM library. It does not give details)A
90 321 :M
-.102(of their implementation except in a few cases where such knowledge would be helpful for)A
90 333 :M
-.118(improving the efficiency or accuracy of a simulation.  The presentation assumes that the reader)A
90 345 :M
-.115(is familiar with the C programming language.  It also assumes a familiarity with discrete-event)A
90 357 :M
-.107(simulation including both event-driven and process-oriented techniques.  The manual gives the)A
90 369 :M
-.102(minimal amount of information needed to use the simulators.  It is not a tutorial, since it has)A
90 381 :M
-.073(very few examples and most of the descriptions are brief.  On the other hand, it should provide)A
90 393 :M
-.131(sufficient information for an experienced C programmer to write simulations in the YACSIM)A
90 405 :M
-.039(language.)A
90 429 :M
f9_12 sf
2.954 .295(1.1.  SIMULATION OBJECTS)J
90 453 :M
f7_12 sf
-.107(The YACSIM extensions to C are organized as a set of objects, each with an underlying data)A
90 465 :M
-.11(structure and a set of operations for manipulating that structure.  These objects will be called)A
90 477 :M
f11_12 sf
-.098(simulation objects )A
f7_12 sf
-.097(in this manual.  There are several types of simulation objects, and the user)A
90 489 :M
-.138(can declare multiple instances of each.)A
90 513 :M
-.117(We group the simulation objects into three categories: )A
f11_12 sf
-.106(activities)A
f7_12 sf
-.074(, )A
f11_12 sf
-.136(queues)A
f7_12 sf
-.108(, and )A
f11_12 sf
-.111(statistics records)A
f7_12 sf
(.)S
90 525 :M
-.132(Activities model the active components of a simulation.  They account for the passage of time)A
90 537 :M
-.062(and modify the state of a simulation.  There are two types of queues, those used for)A
90 549 :M
-.069(synchronization and those used to model resources.  We use the term queue for this group of)A
90 561 :M
-.125(objects because they all contain an internal queue to hold waiting activities.  Statistics records)A
90 573 :M
-.126(simplify the collection and presentation of information generated by a simulation.)A
90 597 :M
-.098(There are two types of activities: )A
f11_12 sf
-.101(events )A
f7_12 sf
-.109(and )A
f11_12 sf
-.107(processes.)A
f7_12 sf
-.101(  They are used to represent activity in a)A
90 609 :M
-.068(simulated system.  Some simulation languages only have events for this purpose, and the only)A
90 621 :M
-.127(way a simulation can advance time is to schedule an event to occur at some time in the future.)A
90 633 :M
-.098(These languages are called )A
f11_12 sf
-.1(event-driven)A
f7_12 sf
-.097(.  Simulation languages that are based on processes are)A
90 645 :M
-.073(said to be )A
f11_12 sf
-.083(process-oriented)A
f7_12 sf
-.078(.  In process-oriented simulations, the processes can account for the)A
90 657 :M
-.096(passage of time by delaying themselves for some time interval.   In general, event-driven)A
90 669 :M
-.089(simulators are more efficient than those that are process-oriented.  On the other hand, process-)A
90 681 :M
-.109(oriented simulators are usually thought to be easier and more natural to use.  Since YACSIM)A
90 693 :M
-.073(has both events and processes, the user can write either event-driven or process-oriented)A
90 705 :M
-.106(simulations or can mix the two.  Furthermore, YACSIM is implemented so that the extra)A
90 717 :M
-.06(overhead of process-oriented simulation is not incurred unless processes are used.)A
endp
%%Page: 5 5
%%BeginPageSetup
initializepage
(; page: 5 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.548(Introduction)A
532 59 :M
(2)S
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.074(The queues used for synchronization are )A
f11_12 sf
-.086(semaphores)A
f7_12 sf
-.045(, )A
f11_12 sf
-.074(barriers)A
f7_12 sf
-.045(, )A
f11_12 sf
-.07(flags)A
f7_12 sf
-.066(, and )A
f11_12 sf
-.075(conditions)A
f7_12 sf
-.077(.  They are)A
90 93 :M
-.09(used to delay the progress of a process or the occurrence of an event until some conditions are)A
90 105 :M
-.081(met.  A process or event waits in the internal queues of these objects until this happens.)A
90 117 :M
-.085(Semaphores, barriers, and flags are similar to synchronization objects found in many parallel)A
90 129 :M
-.09(programming languages and operating systems.  Conditions are a generalized form of these)A
90 141 :M
-.116(other three.  They use expressions involving simulation objects called )A
f11_12 sf
-.112(state variables.)A
f7_12 sf
-.138(  There)A
90 153 :M
-.166(are two types of state variables: )A
f11_12 sf
-.17(integer state variables)A
f7_12 sf
-.17( and )A
f11_12 sf
-.168(floating point state variables)A
f7_12 sf
(.)S
90 177 :M
-.084(Resources are included to simplify the  simulation of  queuing systems consisting of queues)A
90 189 :M
-.022(and servers.  In these systems, processes request service from a resource server.  If all servers)A
90 201 :M
-.053(are busy, the process waits in the resource's internal queue until one becomes free.  The order)A
90 213 :M
-.103(in which processes are removed from a resource queue is determined by rules called the)A
90 225 :M
-.073(resource's queuing discipline.  Several common queuing disciplines are implemented.)A
90 249 :M
-.114(There is only one type of statistics record.  It is a simulation object that can be used to collect)A
90 261 :M
-.093(information about a simulated system.  The statistics records in YACSIM work on sequences)A
90 273 :M
-.094(of weighted values sent them during a simulation.  They can be used to compute the mean,)A
90 285 :M
-.058(variance, max, min, and histogram of such a sequence.  Operations for displaying the)A
90 297 :M
-.11(information collected by statistics records are provided.  They can be used to generate a report)A
90 309 :M
-.06(in a standard form, or to construct one in a user-defined format.)A
90 333 :M
-.113(In addition to the procedures used to manipulate the simulation objects, there are a few other)A
90 345 :M
-.106(procedures provided to control the simulation. The user uses these to initiate the execution of a)A
90 357 :M
-.091(simulation, to reset the simulator for another run, and to interrupt the simulator during a)A
90 369 :M
-.066(simulation.)A
90 393 :M
f9_12 sf
3.139 .314(1.2.  USING SIMULATION OBJECTS)J
90 417 :M
f7_12 sf
-.127(A simulation object consists of a data structure and operations that can be used to manipulate)A
90 429 :M
-.131(that data structure.  YACSIM has been implemented to encourage the user to perform all)A
90 441 :M
-.086(manipulation of these data structures through the operations provided for that purpose.  The)A
90 453 :M
-.098(details of the data structures are hidden from the user and should not be needed to use the)A
90 465 :M
-.092(simulation objects.  This approach is a standard feature of object oriented systems and is)A
90 477 :M
-.07(generally viewed as a desirable way to structure programs.  Unfortunately, C does not have the)A
90 489 :M
-.12(ability to hide global names from the user.  Therefore, all internal YACSIM global names begin)A
90 501 :M
-.07(with the characters "YS__".  To avoid name conflicts, the user should avoid using any names)A
90 513 :M
-.051(that start this way.)A
90 537 :M
-.11(All of the simulation object operations access the simulation objects through pointers.  For each)A
90 549 :M
-.12(object there is an operation that creates a new instance of the object and returns a pointer to it.)A
90 561 :M
-.095(Since these operations perform necessary initialization of the objects, the user should always)A
90 573 :M
-.072(use them when a new object is needed.)A
90 597 :M
-.13(For each simulation object, a new data type \(implemented as a C typedef\) is available to the)A
90 609 :M
-.101(user.  These new types are summarized in the following table.  Although the IVAR and FVAR)A
90 621 :M
-.084(objects do not contain queues, we have grouped them with the queue objects, since they are)A
90 633 :M
-.087(only used with conditions that do contain queues.  Since all access to the objects should be)A
90 645 :M
-.067(through the operations provided by YACSIM, and they only work on pointers to the objects,)A
90 657 :M
-.097(the user should only declare pointers to these new data types instead of declaring instances of)A
90 669 :M
-.123(them.  These pointers must then be initialized with the operation that creates and returns a)A
90 681 :M
-.1(pointer to a new object of that type.)A
endp
%%Page: 6 6
%%BeginPageSetup
initializepage
(; page: 6 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.548(Introduction)A
532 59 :M
(3)S
88 63 -1 1 542 62 1 88 62 @a
162 93 :M
f7_12 sf
12 f13_1 :p
44 :m
-.295(Activities)A
274 93 :M
35 :m
-.196(Queues)A
380 93 :M
84 :m
-.097(Statistics Records)A
162 113 :M
(PROCESS)S
260 113 :M
-.208(SEMAPHORE)A
396 113 :M
-.222(STATREC)A
162 125 :M
-.329(EVENT)A
260 125 :M
-.167(BARRIER)A
260 137 :M
-.109(FLAG)A
260 149 :M
-.204(CONDITION)A
260 161 :M
-.165(     IVAR)A
260 173 :M
-.125(     FVAR)A
260 185 :M
-.096(RESOURCE)A
220 203 :M
f9_12 sf
2.585 .258(Table 1. Simulation Object Types)J
90 227 :M
2.973 .297(1.3.  THE FUNCTIONS main\(\) AND UserMain\(\))J
90 251 :M
f7_12 sf
-.06(Unlike standard C programs, your program must not contain the function main\(\).  In its place,)A
90 263 :M
-.1(you must use a function called )A
f11_12 sf
-.112(UserMain\(\).)A
f7_12 sf
-.097(  The function main\(\) is in the simulation library.)A
90 275 :M
-.121(As usual, it will be called to start the simulation.  It will perform several initializations and then)A
90 287 :M
-.105(call the function UserMain\(\).  When UserMain\(\) terminates, it will return to main\(\) which will)A
90 299 :M
-.11(also terminate.  The usual way to get a simulation started is to create one or more events or)A
90 311 :M
-.076(processes and schedule them from within UserMain\(\).  Then transfer to the driver using the)A
90 323 :M
-.078(DriverRun\(\) operation \(see Chapter 5\).)A
90 347 :M
f9_12 sf
2.691 .269(1.4.  COMMAND LINE ARGUMENTS)J
90 371 :M
f7_12 sf
-.132(There are some pre-defined command line arguments that can be used to control certain aspects)A
90 383 :M
-.099(of a simulation.  They are stripped off by the simulator at the start of a simulation and used to)A
90 395 :M
-.099(control the display of messages at the beginning and end of a simulation, the level of program)A
90 407 :M
-.078(tracing, and the type of event list that will be used.  If used, they must appear at the very)A
90 419 :M
-.113(beginning of the list of command line arguments.  The pre-defined command line arguments)A
90 431 :M
-.144(are listed below:)A
126 455 :M
-.164(+t)A
f11_12 sf
(i)S
162 455 :M
f7_12 sf
-.079(sets the level of trace output produced to )A
f11_12 sf
-.057(i)A
f7_12 sf
-.081(.  Tracing is explained in Section 6.3.)A
162 467 :M
-.077(The default level is 0, which turns off all tracing.)A
126 491 :M
-.04(+b)A
f11_12 sf
(i)S
162 491 :M
f7_12 sf
-.037(Sets the number of bins for the event list's calendar queue to )A
f11_12 sf
(i)S
f7_12 sf
-.027(.  If )A
f11_12 sf
(i)S
f7_12 sf
-.04( = 1, a)A
162 503 :M
-.113(simple sequential search event list will be used instead of the calendar queue.)A
162 515 :M
-.112(The calendar queue implementation of the event list is described in Section 5.2.)A
162 527 :M
-.131(The default event list is a calendar queue with automatic bin sizing.)A
126 551 :M
.462(+w)A
f11_12 sf
(x)S
162 551 :M
f7_12 sf
-.07(Sets the bin size for the event list's calendar queue to )A
f11_12 sf
-.083(x)A
f7_12 sf
-.08(.  The calendar queue)A
162 563 :M
-.112(implementation of the event list is described in Section 5.2.  The default event)A
162 575 :M
-.118(list is a calendar queue with automatic bin sizing.)A
126 599 :M
-.102(+l)A
162 599 :M
-.125(Selects the simple linear linked list implementation of the event list.  Using this)A
162 611 :M
-.113(argument has exactly the same effect as the +b1 argument.)A
126 635 :M
(-h)S
162 635 :M
-.06(Suppresses messages at the beginning and end of a simulation.)A
126 659 :M
-.327(-i)A
162 659 :M
-.085(Suppresses the printing of all unique ID numbers in the trace output.  The)A
162 671 :M
-.084(number 0 is printed instead.  The ability to do this is sometimes useful during)A
162 683 :M
-.097(debugging for comparing two traces for similar simulations where the unique)A
162 695 :M
-.091(ID is different for almost all objects, but there are few other differences.)A
endp
%%Page: 7 7
%%BeginPageSetup
initializepage
(; page: 7 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.548(Introduction)A
532 59 :M
(4)S
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.119(Once the pre-defined control arguments have been read and processed, all the remaining)A
90 93 :M
-.107(command line arguments are passed to UserMain\(\) unchanged.  They are accessed using )A
f11_12 sf
-.154(argc)A
90 105 :M
f7_12 sf
-.115(and )A
f11_12 sf
-.125(argv)A
f7_12 sf
-.116( in the same way command line arguments are accessed in main\(\).)A
90 129 :M
f9_12 sf
2.88 .288(1.5.  COMPILING YACSIM SIMULATIONS)J
90 153 :M
f7_12 sf
-.08(To compile a simulation program under the UNIX operating system, you need access to two)A
90 165 :M
-.03(files, )A
f11_12 sf
-.041(sim.h)A
f7_12 sf
-.037( and )A
f11_12 sf
-.042(yacsim.o)A
f7_12 sf
-.033(.  The file )A
f11_12 sf
-.041(sim.h)A
f7_12 sf
-.038( should be included in all the files that make up your)A
90 177 :M
-.087(program.  It contains useful pre-defined symbols, declarations of all the YACSIM operations)A
90 189 :M
-.088(available to the user, and definitions of the simulation object types.  The file )A
f11_12 sf
-.102(yacsim.o)A
f7_12 sf
-.093( is the)A
90 201 :M
-.113(library of all YACSIM operations.)A
90 225 :M
-.12(To compile a simulation program, use a command line of the form:)A
126 252 :M
f11_14 sf
.787 .079(cc "your options for the compiler" "your files" yacsim.o)J
90 276 :M
f7_12 sf
-.052(You may include any options you want for the C compiler such as -g, -o, etc.  To use this)A
90 288 :M
-.058(command, you must put )A
f11_12 sf
-.055(sim.h)A
f7_12 sf
-.05( and )A
f11_12 sf
-.057(yacsim.o)A
f7_12 sf
-.054( where the compiler can find them, for example in)A
90 300 :M
-.089(the same directory as the source code for the simulation program, or use full path names for)A
90 312 :M
(them.)S
90 336 :M
-.14(An alternative way to compile a simulation program is to use a command line of the form:)A
126 363 :M
f11_14 sf
.837 .084(yacsim "your options for the compiler" "your files")J
90 387 :M
f7_12 sf
-.053(To use this form, both sim.h and yacsim.o, along with the command file yacsim, must all be in)A
90 399 :M
-.11(the same directory, and that directory must have been passed to the command program yacsim)A
90 411 :M
-.071(when it was compiled.  The full name of this directory must be on your search path.)A
endp
%%Page: 8 8
%%BeginPageSetup
initializepage
(; page: 8 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
532 739 :M
f4_12 sf
(5)S
246 86 :M
f9_18 sf
2.876 .288(2.  ACTIVITIES)J
90 119 :M
f7_12 sf
-.077(There are two types of activities: processes and events.  When you create a process or event,)A
90 131 :M
-.101(you assign it a user-defined C procedure that specifies its action.  We call this procedure the)A
90 143 :M
f11_12 sf
(body)S
f7_12 sf
.007 .001( of the process or event.)J
90 167 :M
-.106(The main difference between a process and an event is that the body of a process can)A
90 179 :M
-.067(temporarily suspend execution, while the body of an event can not.  That is, once the body of)A
90 191 :M
-.093(an event starts executing, it must continue until it terminates.  As a result, processes can have a)A
90 203 :M
-.126(lifetime that extends over a period of simulation time, while an event occurs at one instant in)A
90 215 :M
-.118(simulation time.  Simulation time can advance during the lifetime of a process, but not while)A
90 227 :M
-.078(the body of an event executes.)A
90 251 :M
-.144(An important characteristic common to both types of activities is that you can schedule them to)A
90 263 :M
-.082("happen" in the future.  You do this by specifying the conditions which must be met for the)A
90 275 :M
-.12(activity to happen.  Once scheduled, the activity is in limbo until these conditions are met.  At)A
90 287 :M
-.113(that time it starts executing its body.)A
90 311 :M
-.093(This chapter describes the properties and uses of the two types of YACSIM activities.)A
90 323 :M
-.066(Processes and events are scheduled in the same way.  Therefore, we will describe the)A
90 335 :M
-.129(scheduling operations and those other operations that are common to all activities in Section)A
90 347 :M
-.02(2.1.   Sections 2.2 and 2.3 describe those features that are unique to processes and events,)A
90 359 :M
-.081(respectively.)A
90 383 :M
f9_12 sf
1.934 .193(2.1.  OPERATIONS COMMON TO ALL ACTIVITIES)J
90 407 :M
f7_12 sf
-.13(There are five different ways to specify the conditions that determine when an activity will)A
90 419 :M
-.119(happen.  You can schedule an activity to happen:)A
126 443 :M
1(1.)A
148 443 :M
-.136(after a given time delay,)A
126 455 :M
1(2.)A
148 455 :M
-.073(when a given semaphore value is positive,)A
126 467 :M
1(3.)A
148 467 :M
-.04(when a given flag is set,)A
126 479 :M
1(4.)A
148 479 :M
-.042(when a given condition holds, or)A
126 491 :M
1(5.)A
148 491 :M
-.088(after a requested amount of service from a resource.)A
90 515 :M
-.103(There is a separate scheduling operation for each of these five ways to schedule an activity.)A
90 539 :M
-.072(The detailed operation of semaphores, flags, conditions, and resources is the subject of a later)A
90 551 :M
-.042(chapter.  For now, it is not necessary to know how to change semaphore values or to set flags)A
90 563 :M
-.043(in order to discuss the scheduling of events.  For the following discussion, it is also sufficient)A
90 575 :M
-.08(to know that a condition is defined by an expression that is either true or false.  If this)A
90 587 :M
-.074(expression is true, we say that the condition holds.  Resources contain a queue of activities)A
90 599 :M
-.09(waiting for service and one or more servers.  The order in which activities waiting in a)A
90 611 :M
-.045(resource's queue receive service from its server\(s\) is determined by the resource's queuing)A
90 623 :M
-.066(discipline.)A
90 647 :M
-.124(You can schedule an activity at any point in a program that has access to the activity.  In)A
90 659 :M
-.08(particular, you can schedule it from within the body of a process or event as well as from)A
90 671 :M
-.108(within code segments that are not part of any activity.  If you schedule an activity from within a)A
90 683 :M
-.075(process, this can have one of the following three effects on that process:)A
endp
%%Page: 9 9
%%BeginPageSetup
initializepage
(; page: 9 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
532 59 :M
(6)S
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f7_12 sf
1(1.)A
148 81 :M
-.106(It can cause the scheduling process to suspend until the scheduled activity)A
148 93 :M
-.067(terminates.  In this case we say that the scheduling process is )A
f11_12 sf
-.091(blocked)A
148 105 :M
f7_12 sf
-.142(waiting for the activity to terminate.)A
126 129 :M
1(2.)A
148 129 :M
-.141(It can link the scheduled activity with other activities scheduled by the same)A
148 141 :M
-.064(process.  We say that all such linked activities are )A
f11_12 sf
-.071(forked)A
f7_12 sf
-.07( by the process.)A
148 153 :M
-.115(Later, the scheduling process can execute a "join" operation that will cause)A
148 165 :M
-.108(it to suspend until all of its forked activities have terminated. The process)A
148 177 :M
-.155(that performs a forking schedule is called the )A
f11_12 sf
-.173(parent)A
f7_12 sf
-.144( of the activities it)A
148 189 :M
-.094(forks, and the forked activities are called )A
f11_12 sf
-.104(children)A
f7_12 sf
-.1( of the parent process.)A
126 213 :M
1(3.)A
148 213 :M
-.102(Finally, the action of an activity scheduled by a process need not have any)A
148 225 :M
-.078(effect on the process.  In this case, we say that the scheduled activity and)A
148 237 :M
-.073(the scheduling process are )A
f11_12 sf
-.082(independent)A
f7_12 sf
(.)S
90 261 :M
-.069(Processes terminate when their bodies terminate.  The suspension of a process is not a)A
90 273 :M
-.095(termination.  Events normally terminate when their bodies terminate \(i.e., the body routine)A
90 285 :M
-.064(returns\).  However, an event can be designated as non-deleting, in which case it can be)A
90 297 :M
-.127(scheduled multiple times before it terminates.  These events are not viewed as terminated by a)A
90 309 :M
-.121(forking or blocked parent process until they are converted to a deleting type event as explained)A
90 321 :M
.198 .02(in Section 2.3.)J
90 345 :M
-.09(It is frequently useful to pass an argument to an activity when it is scheduled.  This is similar to)A
90 357 :M
-.076(passing arguments to subroutines.  YACSIM uses the operations ActivitySetArg\(\),)A
90 369 :M
-.099(ActivityGetArg\(\), and ActivityArgSize\(\) for this purpose.)A
90 393 :M
f5_12 sf
.634(Operations:)A
90 417 :M
f7_12 sf
-.139(The following five scheduling operations all use the arguments )A
f11_12 sf
-.143(aptr)A
f7_12 sf
-.129( that points to the activity to)A
90 429 :M
-.094(be scheduled and )A
f11_12 sf
-.085(blkflg)A
f7_12 sf
-.087( to specify the effect of a scheduled activity's termination on a)A
90 441 :M
-.091(scheduling process as described above.  A non-deleting event \(defined in the section on events)A
90 453 :M
-.111(below\) may reschedule itself by calling the schedule operation from within its body with a)A
90 465 :M
-.15(NULL )A
f11_12 sf
-.107(aptr)A
f7_12 sf
-.107( argument.  The pre-defined symbol ME can also be used for )A
f11_12 sf
-.107(aptr)A
f7_12 sf
-.098( in this case.)A
90 477 :M
-.13(Otherwise, )A
f11_12 sf
-.129(aptr)A
f7_12 sf
-.125( must point to some activity or the simulator will generate an error message and)A
90 489 :M
-.04(terminate.  The allowable values for )A
f11_12 sf
-.038(blkflg)A
f7_12 sf
-.054( are INDEPENDENT, BLOCK, and FORK.)A
90 501 :M
-.039(Scheduling a forked or blocking activity \(i.e., )A
f11_12 sf
-.038(blkflg)A
f7_12 sf
-.048( = BLOCK or FORK\) other than from)A
90 513 :M
-.104(within the body of a process will generate an error message and terminate the simulation.)A
90 537 :M
f11_12 sf
.056 .006(void ActivitySchedTime\(aptr, timeinc, blkflg\))J
90 549 :M
.143 .014(ACTIVITY *aptr;)J
90 561 :M
-.212(double timeinc;)A
90 573 :M
-.099(int blkflg;)A
108 591 :M
f7_12 sf
.402 .04(This operation schedules the activity pointed to by )J
f11_12 sf
.108(aptr)A
f7_12 sf
.262 .026( to happen in )J
f11_12 sf
.109(timeinc)A
f7_12 sf
.304 .03( units of)J
-1 -1 91 594 1 1 90 576 @b
108 603 :M
.103 .01(time.  If timeinc is 0.0, the activity happens at the current simulation time.  If it is less)J
-1 -1 91 606 1 1 90 593 @b
108 615 :M
-.047(than 0.0, an error termination will occur.)A
-1 -1 91 618 1 1 90 605 @b
90 639 :M
f11_12 sf
.148 .015(void ActivitySchedSema\(aptr, semptr, blkflg\))J
90 651 :M
.143 .014(ACTIVITY *aptr;)J
90 663 :M
-.036(SEMAPHORE *semptr;)A
90 675 :M
-.099(int blkflg;)A
108 693 :M
f7_12 sf
-.059(This operation schedules the activity pointed to by )A
f11_12 sf
-.062(aptr)A
f7_12 sf
-.064( on the semaphore pointed to by)A
-1 -1 91 696 1 1 90 678 @b
108 705 :M
f11_12 sf
.273(semptr)A
f7_12 sf
.793 .079(.  If that semaphore is positive at the time the activity is scheduled, then the)J
-1 -1 91 708 1 1 90 695 @b
108 717 :M
2.183 .218(activity is initiated immediately and the semaphore value decremented.  If the)J
-1 -1 91 720 1 1 90 707 @b
endp
%%Page: 10 10
%%BeginPageSetup
initializepage
(; page: 10 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
532 59 :M
(7)S
88 63 -1 1 542 62 1 88 62 @a
108 81 :M
f7_12 sf
.195 .019(semaphore's value is less than or equal to zero, the initiation of the activity is delayed)J
-1 -1 91 84 1 1 90 71 @b
108 93 :M
.964 .096(until the semaphore becomes positive.  See the section on semaphores below for a)J
-1 -1 91 96 1 1 90 83 @b
108 105 :M
-.041(description of what happens when several activities are waiting at a semaphore when it)A
-1 -1 91 108 1 1 90 95 @b
108 117 :M
-.061(becomes positive.)A
-1 -1 91 120 1 1 90 107 @b
90 141 :M
f11_12 sf
-.014(void ActivitySchedFlag\(aptr, flgptr, blkflg\))A
90 153 :M
.143 .014(ACTIVITY *aptr;)J
90 165 :M
-.055(FLAG *flgptr;)A
90 177 :M
-.099(int blkflg;)A
108 195 :M
f7_12 sf
-.052(This operation schedules the activity pointed to by )A
f11_12 sf
-.055(aptr)A
f7_12 sf
-.05( on the flag pointed to by )A
f11_12 sf
-.049(flgptr)A
f7_12 sf
(.)S
-1 -1 91 198 1 1 90 180 @b
108 207 :M
.534 .053(If that flag is in the set state at the time the activity is scheduled, then the activity is)J
-1 -1 91 210 1 1 90 197 @b
108 219 :M
-.034(initiated immediately and the flag is cleared.  If the flag is in the cleared state when the)A
-1 -1 91 222 1 1 90 209 @b
108 231 :M
1.594 .159(activity is scheduled, the initiation of the activity is delayed until a FlagSet\(\) or)J
-1 -1 91 234 1 1 90 221 @b
108 243 :M
-.01(FlagRelease\(\) operation is performed on the flag.  At that time all activities waiting on)A
-1 -1 91 246 1 1 90 233 @b
108 255 :M
-.157(that flag are initiated.)A
-1 -1 91 258 1 1 90 245 @b
90 279 :M
f11_12 sf
.053 .005(void ActivitySchedCond\(aptr, condptr, blkflg\))J
90 291 :M
.143 .014(ACTIVITY *aptr;)J
90 303 :M
-.11(CONDITION *condptr;)A
90 315 :M
-.099(int blkflg;)A
108 333 :M
f7_12 sf
.064 .006(This operation schedules the activity pointed to by )J
f11_12 sf
.017(aptr)A
f7_12 sf
.056 .006( on the condition pointed to by)J
-1 -1 91 336 1 1 90 318 @b
108 345 :M
f11_12 sf
.403(condptr)A
f7_12 sf
1.163 .116(.  If that condition holds \(i.e., has value TRUE\) at the time the activity is)J
-1 -1 91 348 1 1 90 335 @b
108 357 :M
.733 .073(scheduled, then the activity is initiated immediately.  If the condition does not hold)J
-1 -1 91 360 1 1 90 347 @b
108 369 :M
.239 .024(\(i.e., has value FALSE\) when the activity is scheduled, the initiation of the activity is)J
-1 -1 91 372 1 1 90 359 @b
108 381 :M
1.521 .152(delayed until the condition does hold.  At that time all activities waiting on that)J
-1 -1 91 384 1 1 90 371 @b
108 393 :M
-.143(condition are initiated.)A
-1 -1 91 396 1 1 90 383 @b
90 417 :M
f11_12 sf
.047 .005(void ActivitySchedRes\(aptr, rptr, timeinc, blkflg\))J
90 429 :M
.143 .014(ACTIVITY *aptr;)J
90 441 :M
-.094(RESOURCE *rptr;)A
90 453 :M
-.212(double timeinc;)A
90 465 :M
-.099(int blkflg;)A
108 483 :M
f7_12 sf
-.102(This operation schedules the activity pointed to by )A
f11_12 sf
-.109(aptr)A
f7_12 sf
-.087( for )A
f11_12 sf
-.11(timeinc)A
f7_12 sf
-.106( units of service from)A
-1 -1 91 486 1 1 90 468 @b
108 495 :M
.508 .051(the resource pointed to by )J
f11_12 sf
.143(rptr)A
f7_12 sf
.472 .047(.  The activity will wait in the resource's queue for its)J
-1 -1 91 498 1 1 90 485 @b
108 507 :M
.084 .008(turn to use one of the resource's servers.)J
-1 -1 91 510 1 1 90 497 @b
90 531 :M
-.101(The following operations are used to set and access the arguments of an activity.  The argument)A
90 543 :M
f11_12 sf
-.122(aptr)A
f7_12 sf
-.11( points to that activity.  If a process or event uses any of these operations with  )A
f11_12 sf
-.122(aptr)A
f7_12 sf
-.126( equal to)A
90 555 :M
-.084(NULL or ME, it sets or accesses its own argument.  Otherwise, )A
f11_12 sf
-.084(aptr)A
f7_12 sf
-.081( must point to an activity)A
90 567 :M
-.109(or the simulation will terminate with an error message.)A
90 591 :M
f11_12 sf
-.08(void ActivitySetArg\(aptr, argptr, argsize\))A
90 603 :M
.143 .014(ACTIVITY *aptr;)J
90 615 :M
-.471(char *argptr;)A
90 627 :M
-.302(int argsize;)A
108 645 :M
f7_12 sf
.696 .07(The variable )J
f11_12 sf
.185(argptr)A
f7_12 sf
.559 .056( can point to an arbitrary structure and )J
f11_12 sf
.759 .076(argsize )J
f7_12 sf
.508 .051(is the size of that)J
-1 -1 91 648 1 1 90 630 @b
108 657 :M
-.076(structure in bytes.  Execution of this operation passes this pointer to the activity pointed)A
-1 -1 91 660 1 1 90 647 @b
108 669 :M
.281 .028(to by )J
f11_12 sf
.134(aptr)A
f7_12 sf
.419 .042(.  Note that this operation only passes a pointer to the process, not a value.)J
-1 -1 91 672 1 1 90 659 @b
108 681 :M
-.081(Therefore, when the process accesses the argument pointed to by this pointer, it will get)A
-1 -1 91 684 1 1 90 671 @b
108 693 :M
-.006(the value of the argument at the time it is accessed, and this may not be the same as its)A
-1 -1 91 696 1 1 90 683 @b
108 705 :M
-.062(value when the argument was set.)A
-1 -1 91 708 1 1 90 695 @b
endp
%%Page: 11 11
%%BeginPageSetup
initializepage
(; page: 11 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
532 59 :M
(8)S
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.158(char *ActivityGetArg\(aptr\))A
90 93 :M
.143 .014(ACTIVITY *aptr;)J
108 111 :M
f7_12 sf
-.073(This operation returns a pointer to the arguments of the activity pointed to by )A
f11_12 sf
-.078(aptr)A
f7_12 sf
-.061(.  It is)A
-1 -1 91 114 1 1 90 96 @b
108 123 :M
-.035(usually executed within the body of a process or event \(with aptr = NULL or ME\), and)A
-1 -1 91 126 1 1 90 113 @b
108 135 :M
.892 .089(is the way these activities access their arguments.  The activity must know what is)J
-1 -1 91 138 1 1 90 125 @b
108 147 :M
-.017(pointed to by this pointer and use a cast to change the pointer from a character pointer.)A
-1 -1 91 150 1 1 90 137 @b
108 159 :M
-.04(Moreover, this operation will return the value of the argument at the time the operation)A
-1 -1 91 162 1 1 90 149 @b
108 171 :M
.212 .021(is executed, and this may not be the same as its value when the argument pointer was)J
-1 -1 91 174 1 1 90 161 @b
108 183 :M
.224(set.)A
-1 -1 91 186 1 1 90 173 @b
90 207 :M
f11_12 sf
-.068(int ActivityArgSize\(aptr\))A
90 219 :M
.143 .014(ACTIVITY *aptr;)J
108 237 :M
f7_12 sf
.545 .055(This operation returns the size of the argument of the activity pointed to by )J
f11_12 sf
.164(aptr)A
f7_12 sf
.251 .025(.  A)J
-1 -1 91 240 1 1 90 222 @b
108 249 :M
-.051(return value of -1 means the size is unknown.)A
-1 -1 91 252 1 1 90 239 @b
90 273 :M
-.11(The following two operations provide an activity with a way to get a pointer to itself and to its)A
90 285 :M
-.014(parent, if it has one.)A
90 309 :M
f11_12 sf
.738 .074(ACTIVITY *ActivityGetMyPtr\(\))J
108 327 :M
f7_12 sf
.035 .003(This operation returns a pointer to the currently active activity.  It must be called from)J
-1 -1 91 330 1 1 90 312 @b
108 339 :M
.872 .087(within the body of a process or an event, and it returns a pointer to that process or)J
-1 -1 91 342 1 1 90 329 @b
108 351 :M
(event.)S
-1 -1 91 354 1 1 90 341 @b
90 375 :M
f11_12 sf
.014 .001(ACTIVITY *ActivityGetParPtr\(\))J
108 393 :M
f7_12 sf
-.053(This operation returns a pointer to the parent of the currently active activity.  It must be)A
-1 -1 91 396 1 1 90 378 @b
108 405 :M
.019 .002(called from within the body of a process or an event.  If that process or event has been)J
-1 -1 91 408 1 1 90 395 @b
108 417 :M
.974 .097(scheduled with its block flag set to FORK \(i.e., if the activity is the child of some)J
-1 -1 91 420 1 1 90 407 @b
108 429 :M
.959 .096(parent process\), the operation returns a pointer to the parent process.  Otherwise it)J
-1 -1 91 432 1 1 90 419 @b
108 441 :M
-.028(returns a NULL pointer.)A
-1 -1 91 444 1 1 90 431 @b
90 465 :M
-.125(Statistics can be collected on the states of an activity over its lifetime.  The following operations)A
90 477 :M
-.12(are used to activate this feature and to access the collected statistics.  As with other operations)A
90 489 :M
-.095(on activities, these operations can be called from within the body of a process or an event by)A
90 501 :M
-.122(setting the pointer )A
f11_12 sf
-.137(aptr)A
f7_12 sf
-.135( to NULL or ME.  Note that when an activity terminates its associated)A
90 513 :M
-.093(statistics record is deleted.)A
90 537 :M
f11_12 sf
-.11(void ActivityCollectStats\(aptr\))A
90 549 :M
.143 .014(ACTIVITY *aptr;)J
108 567 :M
f7_12 sf
.021 .002(This operation activates statistics collection for the activity pointed to by )J
f11_12 sf
(aptr)S
f7_12 sf
(.  It does)S
-1 -1 91 570 1 1 90 552 @b
108 579 :M
.863 .086(this by creating a statistics record \(see Chapter 4\) that records the time the activity)J
-1 -1 91 582 1 1 90 569 @b
108 591 :M
-.078(spends in each state.  The possible states are:)A
-1 -1 91 594 1 1 90 581 @b
-1 -1 91 606 1 1 90 594 @b
117 615 :M
-.048(Processes and Events:)A
-1 -1 91 618 1 1 90 606 @b
-1 -1 91 630 1 1 90 618 @b
126 639 :M
-.141(LIMBO - The activity has just been created.)A
-1 -1 91 642 1 1 90 630 @b
126 651 :M
-.111(READY - The activity is ready to execute its body, but has not yet started.)A
-1 -1 91 654 1 1 90 642 @b
126 663 :M
-.044(RUNNING - The activity is executing its body.)A
-1 -1 91 666 1 1 90 654 @b
126 675 :M
-.159(DELAYED - The activity is scheduled for activation in the future.)A
-1 -1 91 678 1 1 90 666 @b
126 687 :M
-.116(WAIT_SEMAPHORE - The activity is waiting for a semaphore to go positive.)A
-1 -1 91 690 1 1 90 678 @b
126 699 :M
-.111(WAIT_FLAG - The activity is waiting for a flag to be set.)A
-1 -1 91 702 1 1 90 690 @b
126 711 :M
-.123(WAIT_CONDITION - The activity is waiting for a condition to hold.)A
-1 -1 91 714 1 1 90 702 @b
endp
%%Page: 12 12
%%BeginPageSetup
initializepage
(; page: 12 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
532 59 :M
(9)S
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f7_12 sf
-.071(WAIT_RESOURCE - The process is in a resource queue.)A
-1 -1 91 84 1 1 90 72 @b
126 93 :M
-.015(USING_RESOURCE - The process is being served by a resource.)A
-1 -1 91 96 1 1 90 84 @b
-1 -1 91 108 1 1 90 96 @b
117 117 :M
-.022(Processes only:)A
-1 -1 91 120 1 1 90 108 @b
-1 -1 91 132 1 1 90 120 @b
126 141 :M
-.103(BLOCKED - The process is waiting for an activity it scheduled to occur.)A
-1 -1 91 144 1 1 90 132 @b
126 153 :M
-.079(WAIT_JOIN - The process is waiting for its forked activities to finish.)A
-1 -1 91 156 1 1 90 144 @b
126 165 :M
-.098(WAIT_BARRIER - The process is waiting at a barrier.)A
-1 -1 91 168 1 1 90 156 @b
126 177 :M
-.083(WAIT_MESSAGE - The process is blocked waiting for a message.)A
-1 -1 91 180 1 1 90 168 @b
90 201 :M
f11_12 sf
-.075(void ActivityStatRept\(aptr\))A
90 213 :M
.143 .014(ACTIVITY *aptr;)J
108 231 :M
f7_12 sf
.311 .031(This operation prints a report on the statistics of the activity pointed to by )J
f11_12 sf
.096(aptr)A
f7_12 sf
.223 .022(.  This)J
-1 -1 91 234 1 1 90 216 @b
108 243 :M
.006 .001(report will give the time and the percentage of the total time that the activity spends in)J
-1 -1 91 246 1 1 90 233 @b
108 255 :M
-.097(each state.)A
-1 -1 91 258 1 1 90 245 @b
90 279 :M
f11_12 sf
-.033(STATREC *ActivityStatPtr\(aptr\))A
90 291 :M
.143 .014(ACTIVITY *aptr;)J
108 309 :M
f7_12 sf
1.048 .105(This operation returns a pointer to the statistics record associated with the activity)J
-1 -1 91 312 1 1 90 294 @b
108 321 :M
-.088(pointed to by )A
f11_12 sf
-.093(aptr)A
f7_12 sf
-.091(.  Chapter 4 describes the various operations that can be performed on)A
-1 -1 91 324 1 1 90 311 @b
108 333 :M
-.1(a statistics record once you have a pointer to it.)A
-1 -1 91 336 1 1 90 323 @b
90 357 :M
f5_12 sf
.668(Examples:)A
126 381 :M
f11_10 sf
.366 .037(ActivitySchedTime\(procptr, 0.0, INDEPENDENT\);)J
162 398 :M
f7_10 sf
-.038(Schedule the independent process pointed to by procptr to start immediately.)A
126 421 :M
f11_10 sf
.366 .037(ActivitySchedTime\(procptr, 4.5, INDEPENDENT\);)J
162 438 :M
f7_10 sf
(Schedule the independent process pointed to by )S
f11_10 sf
(procptr)S
f7_10 sf
( to start in 4.5 time units.)S
126 461 :M
f11_10 sf
.247 .025(ActivitySchedSema\(procptr, semptr, BLOCK\);)J
162 478 :M
f7_10 sf
.019 .002(Schedule the process pointed to by )J
f11_10 sf
(procptr)S
f7_10 sf
.018 .002( to start when the semaphore pointed to by)J
162 489 :M
f11_10 sf
.139(semptr)A
f7_10 sf
.473 .047( is positive, and then suspend the calling process until the scheduled process)J
162 500 :M
.526 .053(terminates.   This blocking form of ActivitySchedSema\(\) can only be invoked by a)J
162 511 :M
-.069(process.)A
126 534 :M
f11_10 sf
-.031(ActivitySchedCond\(procptr, condptr, FORK\);)A
162 551 :M
f7_10 sf
1.015 .101(Fork the process pointed to by )J
f11_10 sf
.32(procptr)A
f7_10 sf
1.013 .101( to start when the condition pointed to by)J
162 562 :M
f11_10 sf
.079(condptr)A
f7_10 sf
.267 .027( holds.  This forking form of ActivitySchedCond\(\) can only be invoked by a)J
162 573 :M
-.069(process.)A
126 596 :M
f11_10 sf
.181 .018(ActivitySchedFlag\(evptr, flgptr, INDEPENDENT\);)J
162 613 :M
f7_10 sf
.1 .01(Schedule the independent event pointed to by )J
f11_10 sf
.026(evptr)A
f7_10 sf
.081 .008( to occur when the flag pointed to)J
162 624 :M
.321 .032(by )J
f11_10 sf
.124(flgptr)A
f7_10 sf
.312 .031( is set.)J
126 647 :M
f11_10 sf
.817 .082(ActivitySchedTime\(ME, 18.4, INDEPENDENT\);)J
162 664 :M
f7_10 sf
.221 .022(If this operation is executed from within a non-deleting event's body, then that event)J
162 675 :M
.15 .015(will be rescheduled to occur in 18.4 time units.  Execution from any place other than)J
162 686 :M
-.013(from within a non-deleting event body is an error.)A
endp
%%Page: 13 13
%%BeginPageSetup
initializepage
(; page: 13 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(10)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
.774 .077(ActivitySchedTime\(evptr, 0.0, BLOCK\);)J
162 98 :M
f7_10 sf
.639 .064(Schedule the event pointed to by )J
f11_10 sf
.183(evptr)A
f7_10 sf
.697 .07( to occur immediately and then suspend the)J
162 109 :M
.057 .006(calling process until the event occurs.)J
126 132 :M
f11_10 sf
.121 .012(float  x = 5.4;)J
126 143 :M
.369 .037(ActivitySetArg\(procptr, &x, sizeof\(float\)\);)J
162 160 :M
f7_10 sf
1.594 .159(A pointer to a floating point argument with value 5.4 is passed to the process)J
162 171 :M
-.035(pointed to by )A
f11_10 sf
-.038(procptr)A
f7_10 sf
(.)S
126 194 :M
f11_10 sf
.142 .014(float  y = *\( \(float*\)ActivityGetArg\(ME\) \);)J
162 211 :M
f7_10 sf
1.37 .137(If this statement is executed from within the body of the process pointed to by)J
162 222 :M
f11_10 sf
.106(procptr)A
f7_10 sf
.3 .03( in the previous example, it will set y to the value 5.4.  The cast is necessary)J
162 233 :M
.133 .013(to prevent a C compile time warning message.)J
90 256 :M
f5_12 sf
.792(Comments:)A
90 280 :M
f7_12 sf
-.088(Although the scheduling operations work for both types of activities, not all possibilities of)A
90 292 :M
-.079(scheduling activities make sense.  For example, you  can not fork or schedule a blocking)A
90 304 :M
-.071(process from any place except within the body of a process, since processes are the only)A
90 316 :M
-.054(objects that can suspend.)A
90 340 :M
-.066(Once you have scheduled a process, you can not schedule it again.  However, under certain)A
90 352 :M
-.069(conditions, you can schedule an event any number of times.  For example, you can reschedule)A
90 364 :M
-.111(a non-deleting event once it occurs.  Attempts to schedule a process more than once or an event)A
90 376 :M
-.064(that has not yet occurred will generate error messages.  Section 2.3 discusses the conditions for)A
90 388 :M
-.106(rescheduling events in more detail.)A
90 412 :M
-.08(It would probably be preferable to pass arguments to processes and events on a stack in the)A
90 424 :M
-.042(same way they are passed to subroutines.  While we could do this for processes, events do not)A
90 436 :M
-.099(have a stack until they occur, and there is no other convenient place to put their arguments.  In)A
90 448 :M
-.057(order to treat both processes and events as uniformly as possible, we have chosen this)A
90 460 :M
-.081(somewhat more cumbersome way of passing arguments using ActivitySetArg\(\),)A
90 472 :M
-.134(ActivityGetArg\(\), and ActivityArgSize\(\).)A
90 496 :M
-.09(If you only need one integer argument, the best way to pass it is to set the argument pointer to)A
90 508 :M
-.094(NULL and the argument size to the value of the argument to be passed.  The process can then)A
90 520 :M
-.111(access this argument with the ActivityArgSize\(\) operation.  This is similar to passing the)A
90 532 :M
-.089(argument on a stack, since a value is passed instead of a pointer to a value.  A situation where)A
90 544 :M
-.066(this is very useful is when you want to create several processes with the same body by using a)A
90 556 :M
-.093(loop.  In this case it is difficult to give each process a different name or to pass a different)A
90 568 :M
-.076(argument value to each one using argument pointers.  If you need some way of distinguishing)A
90 580 :M
-.091(between the different processes, passing a single integer that is incremented for each process)A
90 592 :M
-.077(created is a simple way to do this.)A
90 616 :M
f9_12 sf
3.82 .382(2.2.  PROCESSES)J
90 640 :M
f7_12 sf
-.071(Process-oriented simulators use processes to model the components of a simulated system.)A
90 652 :M
-.112(The usual approach to writing such a simulation is to identify the main components of the)A
90 664 :M
-.059(system to be simulated, and then, for each one, design a process to simulate its behavior.  An)A
90 676 :M
-.126(important characteristic of processes is that they can model the behavior of components that)A
90 688 :M
-.133(operate concurrently.  The simulator coordinates the advancement of simulation time as the)A
90 700 :M
-.085(processes execute in a way that accounts for this concurrent behavior.)A
endp
%%Page: 14 14
%%BeginPageSetup
initializepage
(; page: 14 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(11)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.122(Another important characteristic of processes is that their execution can be suspended and then)A
90 93 :M
-.11(resumed at a later simulation time.  This is one way that the passing of time is modeled during a)A
90 105 :M
-.109(simulation.  For example, a process can delay itself for a given time increment by executing a)A
90 117 :M
-.091("delay" operation.  This halts the execution of the process and puts it on a list of delayed)A
90 129 :M
-.096(processes.  When simulation time advances by the amount of the time increment, the process is)A
90 141 :M
-.094(removed from this list and its execution restarted at the point of interruption.  Processes can)A
90 153 :M
-.107(also delay their execution until some other process performs some specified action.  The main)A
90 165 :M
-.101(mechanisms for this second type of delay are the synchronization and resource objects)A
90 177 :M
-.059(described in Chapter 3.)A
90 201 :M
-.099(For each YACSIM process the user must specify a procedure that defines its behavior.  We call)A
90 213 :M
-.029(this procedure the )A
f11_12 sf
-.037(body)A
f7_12 sf
-.029( of the process.  It can be any C procedure that returns void \(i.e., does)A
90 225 :M
-.077(not return a value\) and has no arguments.  You must specify its body when you create a)A
90 237 :M
-.092(process, and you can not change it after that.  You can create several processes that use the)A
90 249 :M
-.064(same procedure as their bodies.)A
90 273 :M
f5_12 sf
.634(Operations:)A
90 297 :M
f11_12 sf
.566 .057(PROCESS *NewProcess\(pname, bodyname, stksz\))J
90 309 :M
-.298(char *pname)A
90 321 :M
-.075(func bodyname;)A
90 333 :M
-.036(int stksz;)A
108 351 :M
f7_12 sf
-.092(This operation creates a new process and returns a pointer to it.  The argument )A
f11_12 sf
-.124(pname)A
f7_12 sf
-.106( is)A
-1 -1 91 354 1 1 90 336 @b
108 363 :M
1.258 .126(a user-specified name for the process that is used in debugging traces.  )J
f11_12 sf
.462(Func)A
f7_12 sf
.603 .06( is a)J
-1 -1 91 366 1 1 90 353 @b
108 375 :M
1.144 .114(typedef specifying a pointer to a function that returns void and has no arguments.)J
-1 -1 91 378 1 1 90 365 @b
108 387 :M
f11_12 sf
.398(Bodyname)A
f7_12 sf
.955 .095( is any pointer to such a function \(i.e., the name of the function\).  Each)J
-1 -1 91 390 1 1 90 377 @b
108 399 :M
-.036(process has its own private stack, and the argument )A
f11_12 sf
-.034(stksz)A
f7_12 sf
-.034( specifies the size of this stack)A
-1 -1 91 402 1 1 90 389 @b
108 411 :M
.241 .024(in bytes.  If )J
f11_12 sf
.102(stksz)A
f7_12 sf
.424 .042( is 0 or the pre-defined symbol DEFAULTSTK, a default stack size)J
-1 -1 91 414 1 1 90 401 @b
108 423 :M
(will be used.)S
-1 -1 91 426 1 1 90 413 @b
90 447 :M
f11_12 sf
1.034 .103(void ProcessSetStkSz\(stksz\))J
90 459 :M
-.036(int stksz;)A
108 477 :M
f7_12 sf
1.112 .111(The simulator has a built in default stack size that should be satisfactory for most)J
-1 -1 91 480 1 1 90 462 @b
108 489 :M
.161 .016(simulations.  This operation allows the user to change that default value to )J
f11_12 sf
.042(stksz)A
f7_12 sf
.102 .01(.  The)J
-1 -1 91 492 1 1 90 479 @b
108 501 :M
.007 .001(operation must be executed at the very beginning of a simulation, before the operation)J
-1 -1 91 504 1 1 90 491 @b
108 513 :M
.452 .045(NewProcess\(\) is called for the first time.  Otherwise, it will print a warning message)J
-1 -1 91 516 1 1 90 503 @b
108 525 :M
-.117(and leave the default stack size unchanged.)A
-1 -1 91 528 1 1 90 515 @b
90 549 :M
f11_12 sf
-.144(void ProcessDelay\(timeinc\))A
90 561 :M
-.212(double timeinc;)A
108 579 :M
f7_12 sf
.406 .041(You can only invoke this operation from within the body of a process.  Its execution)J
-1 -1 91 582 1 1 90 564 @b
108 591 :M
1.489 .149(causes the suspension of the process for )J
f11_12 sf
.429(timeinc)A
f7_12 sf
1.255 .126( units of simulation time.  If the)J
-1 -1 91 594 1 1 90 581 @b
108 603 :M
1.102 .11(argument is 0.0, the process execution is halted and other processes scheduled for)J
-1 -1 91 606 1 1 90 593 @b
108 615 :M
1.821 .182(execution at the same time are allowed to continue.  If there are no other such)J
-1 -1 91 618 1 1 90 605 @b
108 627 :M
.832 .083(processes, the process continues immediately.  This option gives the programmer a)J
-1 -1 91 630 1 1 90 617 @b
108 639 :M
.674 .067(little control over the order that processes scheduled for the same time will actually)J
-1 -1 91 642 1 1 90 629 @b
108 651 :M
-.106(execute on a uniprocessor.  A negative time increment is not allowed.)A
-1 -1 91 654 1 1 90 641 @b
90 675 :M
f11_12 sf
-.034(void ProcessSleep\(\))A
108 693 :M
f7_12 sf
.406 .041(You can only invoke this operation from within the body of a process.  Its execution)J
-1 -1 91 696 1 1 90 678 @b
108 705 :M
-.018(causes the suspension of that process for an indefinite amount of simulation time.  The)A
-1 -1 91 708 1 1 90 695 @b
endp
%%Page: 15 15
%%BeginPageSetup
initializepage
(; page: 15 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(12)A
88 63 -1 1 542 62 1 88 62 @a
108 81 :M
f7_12 sf
1.111 .111(only way to wake up a sleeping process is to schedule it using one of the activity)J
-1 -1 91 84 1 1 90 71 @b
108 93 :M
-.046(scheduling operations.)A
-1 -1 91 96 1 1 90 83 @b
90 117 :M
f11_12 sf
-.076(void ProcessJoin\(\))A
108 135 :M
f7_12 sf
.887 .089(This is an operation used for synchronization with forked activities.  You can only)J
-1 -1 91 138 1 1 90 120 @b
108 147 :M
.019 .002(invoke it from within the body of a process.  Once executed it will suspend the calling)J
-1 -1 91 150 1 1 90 137 @b
108 159 :M
1.281 .128(process until all activities forked by that process are finished.  That is, all forked)J
-1 -1 91 162 1 1 90 149 @b
108 171 :M
.323 .032(processes must have terminated and all forked events must have occurred.  Once this)J
-1 -1 91 174 1 1 90 161 @b
108 183 :M
-.052(happens, the suspended process continues with the next instruction in its body.  If there)A
-1 -1 91 186 1 1 90 173 @b
108 195 :M
1.778 .178(are no outstanding forked activities when ProcessJoin\(\) is executed, the process)J
-1 -1 91 198 1 1 90 185 @b
108 207 :M
-.077(continues without interruption.)A
-1 -1 91 210 1 1 90 197 @b
90 231 :M
f11_12 sf
-.096(void ProcessSetPriority\(procptr, p\))A
90 243 :M
-.103(PROCESS *procptr;)A
90 255 :M
-.207(double p;)A
108 273 :M
f7_12 sf
-.002(This operation sets the priority of the process pointed to by )A
f11_12 sf
(procptr)S
f7_12 sf
( to )S
f11_12 sf
(p)S
f7_12 sf
(.  Priorities are)S
-1 -1 91 276 1 1 90 258 @b
108 285 :M
-.048(only used when a process requests service from a resource.  Resources are explained in)A
-1 -1 91 288 1 1 90 275 @b
108 297 :M
.51 .051(Section 3.5.  If ProcessSetPriority\(\) is called from within the body of a process with)J
-1 -1 91 300 1 1 90 287 @b
108 309 :M
f11_12 sf
-.047(procptr )A
f7_12 sf
-.048(= NULL or ME, that process sets its own priority.)A
-1 -1 91 312 1 1 90 299 @b
90 333 :M
-.079(Activities can send messages to processes.  These messages are similar to the messages found)A
90 345 :M
-.081(in many message-based operating systems.  Activities use the operation ProcessSendMsg\(\) to)A
90 357 :M
-.083(deliver messages to a process.  Once a message has been delivered, it waits in a queue with)A
90 369 :M
-.115(other messages delivered to the same process.  A process must explicitly receive each delivered)A
90 381 :M
-.095(message \(taking it out of the queue\) with a separate invocation of ProcessReceiveMsg\(\).)A
90 405 :M
f11_12 sf
.575 .058(void ProcessSendMsg\(dest, buf, bytes, blkflg, type\))J
90 417 :M
(PROCESS *dest;)S
90 429 :M
-.258(char *buf;)A
90 441 :M
-.146(int bytes;)A
90 453 :M
-.099(int blkflg;)A
90 465 :M
-.206(int type;)A
108 483 :M
f7_12 sf
.925 .093(This operation can only be called from within the body of an activity.  It creates a)J
-1 -1 91 486 1 1 90 468 @b
108 495 :M
1.011 .101(message consisting of )J
f11_12 sf
.239(bytes)A
f7_12 sf
.796 .08( characters taken from the buffer pointed to by )J
f11_12 sf
.248(buf)A
f7_12 sf
.759 .076( and)J
-1 -1 91 498 1 1 90 485 @b
108 507 :M
-.024(delivers it to the process pointed to by )A
f11_12 sf
-.026(dest)A
f7_12 sf
-.025(.  It also assigns the message a type equal to)A
-1 -1 91 510 1 1 90 497 @b
108 519 :M
1.534 .153(the argument )J
f11_12 sf
.824 .082(type.  )J
f7_12 sf
.409(This)A
f11_12 sf
.209 .021( )J
f7_12 sf
1.156 .116(must be an integer greater than or equal to 0 or an error)J
-1 -1 91 522 1 1 90 509 @b
108 531 :M
.153 .015(termination of the simulation will occur.  The allowable values for )J
f11_12 sf
.039(blkflg)A
f7_12 sf
.179 .018( are BLOCK)J
-1 -1 91 534 1 1 90 521 @b
108 543 :M
.972 .097(and NOBLOCK.  If )J
f11_12 sf
.257(blkflg)A
f7_12 sf
.968 .097(  equals BLOCK, this operation will not return until the)J
-1 -1 91 546 1 1 90 533 @b
108 555 :M
-.022(message has been delivered to, )A
12 f13_1 :p
17.249 :m
-.026(and)A
-.02( received by, the destination process.  Setting )A
f11_12 sf
-.024(blkflg)A
-1 -1 91 558 1 1 90 545 @b
108 567 :M
f7_12 sf
1.148 .115(to NOBLOCK will allow the operation to return as soon as the message has been)J
-1 -1 91 570 1 1 90 557 @b
108 579 :M
.061 .006(delivered to the destination process.  If )J
f11_12 sf
.018(buf)A
f7_12 sf
.043 .004( is NULL or )J
f11_12 sf
.018(bytes)A
f7_12 sf
.05 .005( is 0, a null message \(i.e.,)J
-1 -1 91 582 1 1 90 569 @b
108 591 :M
.047 .005(one with no contents\) is sent.  Null messages are only used for synchronization, not to)J
-1 -1 91 594 1 1 90 581 @b
108 603 :M
-.04(send information.)A
-1 -1 91 606 1 1 90 593 @b
90 627 :M
f11_12 sf
.3 .03(int ProcessReceiveMsg\(buf, bytes, blkflg, type, sender\))J
90 639 :M
-.258(char *buf;)A
90 651 :M
-.146(int bytes;)A
90 663 :M
-.099(int blkflg;)A
90 675 :M
-.206(int type;)A
90 687 :M
-.042(PROCESS *sender;)A
108 705 :M
f7_12 sf
-.006(A process uses this operation to receive delivered messages.  Since only processes can)A
-1 -1 91 708 1 1 90 690 @b
108 717 :M
1.722 .172(receive messages, you can only invoke the operation from within the body of a)J
-1 -1 91 720 1 1 90 707 @b
endp
%%Page: 16 16
%%BeginPageSetup
initializepage
(; page: 16 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(13)A
88 63 -1 1 542 62 1 88 62 @a
108 81 :M
f7_12 sf
.901 .09(process.  The operation receives a message by moving the message contents into a)J
-1 -1 91 84 1 1 90 71 @b
108 93 :M
-.073(buffer pointed to by )A
f11_12 sf
-.079(buf)A
f7_12 sf
-.072(.  If the size of the message is less than or equal to the argument)A
-1 -1 91 96 1 1 90 83 @b
108 105 :M
f11_12 sf
.172(bytes,)A
f7_12 sf
.632 .063( all the characters in the message are copied into the buffer, and the operation)J
-1 -1 91 108 1 1 90 95 @b
108 117 :M
.077 .008(returns the number of characters received.  If the message is larger than )J
f11_12 sf
.021(bytes,)A
f7_12 sf
.063 .006( only its)J
-1 -1 91 120 1 1 90 107 @b
108 129 :M
.483 .048(first )J
f11_12 sf
.171(bytes)A
f7_12 sf
.571 .057( characters will be moved, and the operation will return the value -2.  The)J
-1 -1 91 132 1 1 90 119 @b
108 141 :M
2.333 .233(remaining characters of the message can be obtained with subsequent calls to)J
-1 -1 91 144 1 1 90 131 @b
108 153 :M
-.025(ProcessReceiveMsg\(\).  If the operation returns 0, then a null message was received.  A)A
-1 -1 91 156 1 1 90 143 @b
108 165 :M
.052 .005(blocking sender will not be released until the entire message it sent has been received.)J
-1 -1 91 168 1 1 90 155 @b
108 177 :M
1.869 .187(The arguments )J
f11_12 sf
.425(type)A
f7_12 sf
.795 .079( and )J
f11_12 sf
.454(sender)A
f7_12 sf
1.232 .123( can be used to restrict the type and origin of the)J
-1 -1 91 180 1 1 90 167 @b
108 189 :M
.166 .017(message that will be received.  )J
f11_12 sf
.059(Type)A
f7_12 sf
.152 .015( must match the type of the message as set by the)J
-1 -1 91 192 1 1 90 179 @b
108 201 :M
.036 .004(sender, and )J
f11_12 sf
.011(sender)A
f7_12 sf
.035 .003( must match a pointer to the sending process, before a message will)J
-1 -1 91 204 1 1 90 191 @b
108 213 :M
.276 .028(be received.  The operation will search the entire queue of delivered messages, in the)J
-1 -1 91 216 1 1 90 203 @b
108 225 :M
-.062(order of their delivery, looking for the first one that matches these arguments.  The pre-)A
-1 -1 91 228 1 1 90 215 @b
108 237 :M
.544 .054(defined symbols ANYTYPE and ANYSENDER may be used to accept messages of)J
-1 -1 91 240 1 1 90 227 @b
108 249 :M
-.002(any type and from any sending process.  If the value of )A
f11_12 sf
(blkflg)S
f7_12 sf
-.002( is BLOCK, and there no)A
-1 -1 91 252 1 1 90 239 @b
108 261 :M
.056 .006(messages available that match the )J
f11_12 sf
.014(type)A
f7_12 sf
.026 .003( and )J
f11_12 sf
.015(sender)A
f7_12 sf
.057 .006( arguments, then the calling process)J
-1 -1 91 264 1 1 90 251 @b
108 273 :M
.279 .028(will suspend until one is delivered.  If )J
f11_12 sf
.083(blkflg)A
f7_12 sf
.343 .034( is NOBLOCK and no such message has)J
-1 -1 91 276 1 1 90 263 @b
108 285 :M
-.085(been delivered, then ProcessReceiveMsg\(\) will return the value -1.)A
-1 -1 91 288 1 1 90 275 @b
90 309 :M
f11_12 sf
-.038(int *ProcessCheckMsg\(type, sender\))A
90 321 :M
-.206(int type;)A
90 333 :M
-.042(PROCESS *sender;)A
108 351 :M
f7_12 sf
.094 .009(A process can use this operation to check whether or not it has a message of type )J
f11_12 sf
.041(type)A
-1 -1 91 354 1 1 90 336 @b
108 363 :M
f7_12 sf
.206 .021(from the process pointed to by )J
f11_12 sf
.067(sender)A
f7_12 sf
.193 .019( in its queue of delivered messages.  It can only)J
-1 -1 91 366 1 1 90 353 @b
108 375 :M
1.171 .117(be used from within the body of a process.  It returns -1 if there are no delivered)J
-1 -1 91 378 1 1 90 365 @b
108 387 :M
.622 .062(messages of the indicated type and sender waiting to be received.  If there is such a)J
-1 -1 91 390 1 1 90 377 @b
108 399 :M
-.066(message, the operation returns the size of the message.)A
-1 -1 91 402 1 1 90 389 @b
90 423 :M
f5_12 sf
.668(Examples:)A
126 447 :M
f11_10 sf
.165 .016(procptr1 = NewProcess\("SW1", switch, DEFAULTSTK\);)J
162 464 :M
f7_10 sf
.021 .002(This statement creates a new process with the default stack size and with the function)J
162 475 :M
f11_10 sf
.029(switch)A
f7_10 sf
.085 .009( as its body and the character string "SW1" as its name.  The variable )J
f11_10 sf
.034(procptr1)A
162 486 :M
f7_10 sf
.595 .06(must have been previously declared as a pointer to PROCESS, and )J
f11_10 sf
.163(switch)A
f7_10 sf
.482 .048( must be)J
162 497 :M
.038 .004(the name of a function with no arguments and no return value.)J
126 520 :M
f11_10 sf
-.034(procptr2 = NewProcess\("SW2", switch, 1000\);)A
162 537 :M
f7_10 sf
.218 .022(This statement creates a second process with the same body function as the previous)J
162 548 :M
.309 .031(one, but with a 1000 byte stack.)J
126 571 :M
f11_10 sf
-.167(ProcessDelay\(10.3\);)A
162 588 :M
f7_10 sf
.337 .034(This statement delays the calling process for 10.3 units of time.  Note that this must)J
162 599 :M
(be called only from within a process.)S
126 622 :M
f11_10 sf
-.219(ProcessJoin\(\);)A
162 639 :M
f7_10 sf
-.003(The calling process waits for all forked activities to terminate.)A
126 662 :M
f11_10 sf
.043 .004(ProcessSendMsg\(prptr, sndbuf, 20, NOBLOCK, 0\);)J
162 679 :M
f7_10 sf
.667 .067(Twenty characters from the buffer pointed to by )J
f11_10 sf
.195(sndbuf)A
f7_10 sf
.534 .053( will be sent to the process)J
162 690 :M
1.081 .108(pointed to by )J
f11_10 sf
.354(prptr)A
f7_10 sf
1.149 .115(.  The operation will return as soon as the message has been)J
162 701 :M
.005 .001(delivered, but before it has been received.   The type of the message is set to 0.)J
endp
%%Page: 17 17
%%BeginPageSetup
initializepage
(; page: 17 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(14)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
.337 .034(ProcessSendMsg\(pp, sb, 100, BLOCK, 3\);)J
162 98 :M
f7_10 sf
1.298 .13(This instance of the ProcessSendMsg\(\) operation will send a message of type 3)J
162 109 :M
.437 .044(consisting of 100 characters from the buffer pointed to by )J
f11_10 sf
.132(sb)A
f7_10 sf
.432 .043( to the process pointed)J
162 120 :M
.5 .05(to by )J
f11_10 sf
.285(pp)A
f7_10 sf
.7 .07(.  It is a blocking send so that the calling process will suspend until all of)J
162 131 :M
-.091(the message has been received.)A
126 154 :M
f11_10 sf
.869 .087(i = ProcessReceiveMsg\(rbuf, 1000, BLOCK, ANYTYPE, ANYSENDER\);)J
162 171 :M
f7_10 sf
.56 .056(The calling process tries to receive a message from any sender and of any type.  If)J
162 182 :M
.018 .002(there is such a message and its size is less than or equal to 1000 characters, the whole)J
162 193 :M
1.036 .104(message is copied to the buffer pointed to by )J
f11_10 sf
.297(rbuf,)A
f7_10 sf
.472 .047( and  )J
f11_10 sf
.215(i)A
f7_10 sf
.855 .086( is set to the number of)J
162 204 :M
.095 .009(characters in the message.  if there are more than )J
f11_10 sf
.036(1000)A
f7_10 sf
.11 .011( characters in the message, the)J
162 215 :M
1.936 .194(operation only copies )J
f11_10 sf
.568(1000)A
f7_10 sf
1.436 .144( characters to the buffer and then sets )J
f11_10 sf
.316(i)A
f7_10 sf
.984 .098( to -2.  The)J
162 226 :M
-.061(remaining characters can be read by another call to Process ReceiveMsg\(\).  If there are)A
162 237 :M
-.003(no messages available, the operation will suspend until one is delivered.)A
126 260 :M
f11_10 sf
.018 .002(i = ProcessReceiveMsg\(rbuf, 250, NOBLOCK, 4, rptr\);)J
162 277 :M
f7_10 sf
.574 .057(This operation attempts to receive a message of type 4 from the process pointed to)J
162 288 :M
.237 .024(by )J
f11_10 sf
.096(rptr)A
f7_10 sf
.25 .025(.  If none is available, it will set )J
f11_10 sf
.069(i)A
f7_10 sf
.278 .028( to -1 and return.  If there is such a message)J
162 299 :M
.698 .07(and its size is less than or equal to 250, the whole message is copied to the buffer)J
162 310 :M
.235 .024(pointed to by )J
f11_10 sf
.288 .029(rebuf, )J
f7_10 sf
.146 .015(and  )J
f11_10 sf
.052(i)A
f7_10 sf
.229 .023( is set to the number of characters in the message.  if there)J
162 321 :M
-.014(are more than 250 characters in the message, the operation only copies 250 characters)A
162 332 :M
.361 .036(to the buffer and then sets )J
f11_10 sf
.083(i)A
f7_10 sf
.405 .041( to -2.  The remaining characters can be read by another)J
162 343 :M
-.014(call to Process ReceiveMsg\(\).)A
90 366 :M
f5_12 sf
.792(Comments:)A
90 390 :M
f7_12 sf
-.044(It is possible to overflow a process' stack during a simulation.  This usually results in the)A
90 402 :M
-.089(simulation crashing for no apparent reason.  It can also crash at different points if the)A
90 414 :M
-.057(simulation code is changed \(e.g., by putting in )A
f11_12 sf
-.054(printf)A
f7_12 sf
-.059( statements to find out what is happening\).)A
90 426 :M
-.083(A good rule to follow is to try increasing the stack size of suspect processes if there is no other)A
90 438 :M
-.094(obvious reason for a crash.  On some implementations the maximum size of the stack used by a)A
90 450 :M
-.072(process is printed out in the debugging trace when that process terminates.  Unfortunately, this)A
90 462 :M
-.119(is very machine dependent and may not be implemented on some machines.)A
90 486 :M
f9_12 sf
3.545 .355(2.3.  EVENTS)J
90 510 :M
f7_12 sf
-.075(Events are similar to processes.  When you create an event, you must assign it a body in the)A
90 522 :M
-.038(same way you assign a process body.  When an event occurs, the body is executed.  The)A
90 534 :M
-.101(significant difference is that the body of an event can not suspend execution.  This means that)A
90 546 :M
-.109(once an event body has started execution, it will continue until it reaches a return point.  More)A
90 558 :M
-.126(importantly, if the same event is activated again, it will start executing its body at the same)A
90 570 :M
-.103(entry point as before.  It can not remember where it stopped and restart at that point the way a)A
90 582 :M
-.069(process can.  To put it another way, execution of an event body is the same as a subroutine)A
90 594 :M
-.062(call, where processes use coroutine linkage to implement suspensions.)A
90 618 :M
-.076(The conditions for the body function of an event are the same as for a process.  It must be a C)A
90 630 :M
-.064(function that returns void and has no arguments.  Like processes, several events can use the)A
90 642 :M
-.094(same body function.  When you create an event, you can designate it to be a )A
f11_12 sf
-.094(deleting)A
f7_12 sf
-.079( or a )A
f11_12 sf
-.143(non-)A
90 654 :M
-.1(deleting)A
f7_12 sf
-.099( event.  Just as processes are automatically deleted when they finish executing, a)A
90 666 :M
-.117(deleting event is automatically deleted after it occurs.   A non-deleting event, on the other hand,)A
90 678 :M
-.106(is not deleted after it occurs and can be used again.  Another useful feature of non-deleting)A
90 690 :M
-.098(events is that they can reschedule themselves.  That is, any of the activity scheduling operations)A
90 702 :M
-.1(for an event can appear in the body of that event.)A
endp
%%Page: 18 18
%%BeginPageSetup
initializepage
(; page: 18 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(15)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.089(You can also assign a type to an event.  An event's type is an arbitrary integer value that you)A
90 93 :M
-.123(can assign at the time of creation or later with the event operation EventSetType\(\).  Event types)A
90 105 :M
-.074(are not currently used by the simulator; they are provided for users to use anyway they want.)A
90 117 :M
-.106(For example, a user could collect statistics on event types to count the number of event)A
90 129 :M
-.071(occurrences of a given type.)A
90 153 :M
f5_12 sf
.634(Operations:)A
90 177 :M
f11_12 sf
.399 .04(EVENT *NewEvent\(ename, bodyname, delflg, etype\))J
90 189 :M
-.391(char *ename;)A
90 201 :M
-.075(func bodyname;)A
90 213 :M
-.199(int delflg;)A
90 225 :M
-.219(int etype;)A
108 243 :M
f7_12 sf
-.051(This operation creates a new event and returns a pointer to it.  The argument )A
f11_12 sf
-.075(bodyname)A
-1 -1 91 246 1 1 90 228 @b
108 255 :M
f7_12 sf
2.245 .224(specifies the body function and )J
f11_12 sf
.754(ename)A
f7_12 sf
2.084 .208( names the object.  The third argument)J
-1 -1 91 258 1 1 90 245 @b
108 267 :M
.162 .016(determines whether the event will be deleting or non-deleting.  The only two possible)J
-1 -1 91 270 1 1 90 257 @b
108 279 :M
1.054 .105(values for this argument are DELETE and NODELETE.  The last argument is the)J
-1 -1 91 282 1 1 90 269 @b
108 291 :M
2.35 .235(event's type.  The event's state, used for rescheduling \(see event rescheduling)J
-1 -1 91 294 1 1 90 281 @b
108 303 :M
(operations below\), is set to 0.)S
-1 -1 91 306 1 1 90 293 @b
90 327 :M
f11_12 sf
.085 .008(void EventSetType\(eptr, etype\))J
90 339 :M
-.09(EVENT *eptr;)A
90 351 :M
-.219(int etype;)A
108 369 :M
f7_12 sf
.11 .011(Execution of this operation sets the type of the event pointed to by )J
f11_12 sf
.033(eptr)A
f7_12 sf
.043 .004( to )J
f11_12 sf
.034(etype)A
f7_12 sf
.081 .008(.  You)J
-1 -1 91 372 1 1 90 354 @b
108 381 :M
-.029(can use it to change the type of a non-deleting event before reusing it.  You can invoke)A
-1 -1 91 384 1 1 90 371 @b
108 393 :M
-.078(it within the body of an event with )A
f11_12 sf
-.08(eptr)A
f7_12 sf
-.086( = NULL or ME, enabling an event to change its)A
-1 -1 91 396 1 1 90 383 @b
108 405 :M
.857 .086(own type.  This probably only makes sense for non-deleting events that reschedule)J
-1 -1 91 408 1 1 90 395 @b
108 417 :M
-.031(themselves.)A
-1 -1 91 420 1 1 90 407 @b
90 441 :M
f11_12 sf
-.093(int EventGetType\(eptr\))A
90 453 :M
-.09(EVENT *eptr;)A
108 471 :M
f7_12 sf
.439 .044(This is a function that returns the type of the event pointed to by )J
f11_12 sf
.142(eptr)A
f7_12 sf
.389 .039(.  You can also)J
-1 -1 91 474 1 1 90 456 @b
108 483 :M
.613 .061(invoke it from within the body of an event with )J
f11_12 sf
.19(eptr)A
f7_12 sf
.679 .068( = NULL or ME, which allows)J
-1 -1 91 486 1 1 90 473 @b
108 495 :M
-.037(events to know their types.)A
-1 -1 91 498 1 1 90 485 @b
90 519 :M
f11_12 sf
-.234(int EventGetDelFlag\(eptr\))A
90 531 :M
-.09(EVENT *eptr;)A
108 549 :M
f7_12 sf
.054 .005(This function allows the programmer to determine whether or not the event pointed to)J
-1 -1 91 552 1 1 90 534 @b
108 561 :M
-.081(by )A
f11_12 sf
-.079(eptr)A
f7_12 sf
-.076( is a deleting event by returning the value of its delete flag.  You can also invoke)A
-1 -1 91 564 1 1 90 551 @b
108 573 :M
-.081(it from within the body of an event with )A
f11_12 sf
-.082(eptr)A
f7_12 sf
-.107( = NULL or ME.)A
-1 -1 91 576 1 1 90 563 @b
90 597 :M
-.112(The following operations allow a deleting event to reschedule itself and save its state for use)A
90 609 :M
-.088(during the next occurrence of that event.  The state was set to 0 when the event was created.)A
90 621 :M
-.126(The saved state can be used to give an event a limited capability to suspend and resume)A
90 633 :M
-.093(operation in a way similar to processes.  This is illustrated in the last example below.  All of)A
90 645 :M
-.117(these operations are similar to the corresponding activity scheduling operations with their)A
90 657 :M
-.129(activity pointer argument set to ME.  The only difference is that they also save a state value and)A
90 669 :M
-.105(can only be called from within a non-deleting event body.)A
endp
%%Page: 19 19
%%BeginPageSetup
initializepage
(; page: 19 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(16)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.025(void EventReschedTime\(timeinc, stval\))A
90 93 :M
-.212(double timeinc;)A
90 105 :M
-.258(int stval;)A
108 123 :M
f7_12 sf
1.252 .125(If this operation is executed from within the body of a non-deleting event, it will)J
-1 -1 91 126 1 1 90 108 @b
108 135 :M
-.102(reschedule the event to occur again in )A
f11_12 sf
-.109(timeinc)A
f7_12 sf
-.101( time units and save the value )A
f11_12 sf
-.098(stval)A
f7_12 sf
-.111( for use)A
-1 -1 91 138 1 1 90 125 @b
108 147 :M
.859 .086(during the next occurrence.  Executing the operation from anywhere other than the)J
-1 -1 91 150 1 1 90 137 @b
108 159 :M
-.065(body of a non-deleting event is an error.)A
-1 -1 91 162 1 1 90 149 @b
90 183 :M
f11_12 sf
-.007(void EventReschedSema\(semptr, stval\))A
90 195 :M
-.036(SEMAPHORE *semptr;)A
90 207 :M
-.258(int stval;)A
108 225 :M
f7_12 sf
.277 .028(This operation reschedules an event on a semaphore and saves the value )J
f11_12 sf
.069(stval)A
f7_12 sf
.202 .02( for use)J
-1 -1 91 228 1 1 90 210 @b
108 237 :M
.069 .007(during the next occurrence of the event.  It can only be used within the body of a non-)J
-1 -1 91 240 1 1 90 227 @b
108 249 :M
-.117(deleting event.)A
-1 -1 91 252 1 1 90 239 @b
90 273 :M
f11_12 sf
-.055(void EventReschedFlag\(flgptr, stval\))A
90 285 :M
-.055(FLAG *flgptr;)A
90 297 :M
-.258(int stval;)A
108 315 :M
f7_12 sf
.215 .021(This operation reschedules an event on a flag and saves the value )J
f11_12 sf
.057(stval)A
f7_12 sf
.202 .02( for use during)J
-1 -1 91 318 1 1 90 300 @b
108 327 :M
-.029(the next occurrence of the event.  It can only be used within the body of a non-deleting)A
-1 -1 91 330 1 1 90 317 @b
108 339 :M
(event.)S
-1 -1 91 342 1 1 90 329 @b
90 363 :M
f11_12 sf
-.026(void EventReschedCond\(condptr, stval\))A
90 375 :M
-.11(CONDITION *condptr;)A
90 387 :M
-.258(int stval;)A
108 405 :M
f7_12 sf
.573 .057(This operation reschedules an event on a condition and saves the value )J
f11_12 sf
.145(stval)A
f7_12 sf
.426 .043( for use)J
-1 -1 91 408 1 1 90 390 @b
108 417 :M
.069 .007(during the next occurrence of the event.  It can only be used within the body of a non-)J
-1 -1 91 420 1 1 90 407 @b
108 429 :M
-.117(deleting event.)A
-1 -1 91 432 1 1 90 419 @b
90 453 :M
f11_12 sf
-.021(void EventReschedRes\(resptr, timeinc, stval\))A
90 465 :M
-.11(CONDITION *condptr;)A
90 477 :M
-.212(double timeinc;)A
90 489 :M
-.258(int stval;)A
108 507 :M
f7_12 sf
-.028(This operation reschedules an event to use )A
f11_12 sf
-.03(timeinc)A
f7_12 sf
-.029( units of service from a resource and)A
-1 -1 91 510 1 1 90 492 @b
108 519 :M
.583 .058(saves the value )J
f11_12 sf
.161(stval)A
f7_12 sf
.524 .052( for use during the next occurrence of the event.  It can only be)J
-1 -1 91 522 1 1 90 509 @b
108 531 :M
-.074(used within the body of a non-deleting event.)A
-1 -1 91 534 1 1 90 521 @b
90 555 :M
f11_12 sf
-.099(int EventSetState\(stvat\))A
90 567 :M
-.258(int stval;)A
108 585 :M
f7_12 sf
.162 .016(This operation must be executed from within the body of an event.  It sets the state of)J
-1 -1 91 588 1 1 90 570 @b
108 597 :M
-.1(that event to )A
f11_12 sf
-.102(stval)A
f7_12 sf
(.)S
-1 -1 91 600 1 1 90 587 @b
90 621 :M
f11_12 sf
-.127(int EventGetState\(\))A
108 639 :M
f7_12 sf
-.113(This operation returns the state value saved by a previously executed event rescheduling)A
-1 -1 91 642 1 1 90 624 @b
108 651 :M
-.076(operation.  It must be executed from within the body of an event.)A
-1 -1 91 654 1 1 90 641 @b
90 675 :M
f11_12 sf
-.124(void EventSetDelFlag\(\))A
108 693 :M
f7_12 sf
-.021(This operation can only be called from within the body of an active event.  If the event)A
-1 -1 91 696 1 1 90 678 @b
108 705 :M
.985 .099(is non-deleting, this operation changes it to a deleting event.  It has no effect on a)J
-1 -1 91 708 1 1 90 695 @b
108 717 :M
.266 .027(deleting event.  Once a non-deleting event's delete flag is set, it will terminate and be)J
-1 -1 91 720 1 1 90 707 @b
endp
%%Page: 20 20
%%BeginPageSetup
initializepage
(; page: 20 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(17)A
88 63 -1 1 542 62 1 88 62 @a
108 81 :M
f7_12 sf
-.005(deleted the next time it returns as a subroutine.  If there were blocked parent processes)A
-1 -1 91 84 1 1 90 71 @b
108 93 :M
-.104(waiting for this event to terminate, they will then be released.)A
-1 -1 91 96 1 1 90 83 @b
90 117 :M
f5_12 sf
.668(Examples:)A
126 141 :M
f11_10 sf
.027 .003(evptr1 = NewEvent\("PK1", packet, DELETE, 0\);)J
162 158 :M
f7_10 sf
.329 .033(This creates a new event with the function )J
f11_10 sf
.103(packet)A
f7_10 sf
.228 .023( as its body and )J
f11_10 sf
.124("PK1")A
f7_10 sf
.262 .026( as it name.)J
162 169 :M
.386 .039(Here )J
f11_10 sf
.112(evptr1)A
f7_10 sf
.327 .033( is a pointer to type EVENT.  The event will be a deleting event of type)J
162 180 :M
.5(0.)A
126 203 :M
f11_10 sf
.027 .003(evptr2 = NewEvent\("PK2", packet, DELETE, 0\);)J
162 220 :M
f7_10 sf
-.001(This creates a deleting event with the same body function as the previous one.)A
126 243 :M
f11_10 sf
.222 .022(evp = NewEvent\("SP", sndpck, NODELETE, 3\);)J
162 260 :M
f7_10 sf
.405 .04(This statement declares a non-deleting event with function )J
f11_10 sf
.11(sndpck)A
f7_10 sf
.247 .025( as its body and 3)J
162 271 :M
.487 .049(as its type.)J
126 294 :M
f11_10 sf
.32 .032(EventSetType\(evptr1, 6\);)J
162 311 :M
f7_10 sf
.217 .022(This sets the type of the event pointed to by )J
f11_10 sf
.076(evptr1)A
f7_10 sf
.145 .015( to 6.)J
126 334 :M
f11_10 sf
.746 .075(EventSetType\(ME, 1\);)J
162 351 :M
f7_10 sf
.341 .034(This is the form of the operation if it is executed within the body of the event itself.)J
162 362 :M
.088 .009(In this way it is possible for an event to change its type and then reschedule itself.)J
126 385 :M
f11_10 sf
-.146(i = EventDeleteFlag\(evptr\);)A
162 402 :M
f7_10 sf
.113 .011(This sets the integer )J
f11_10 sf
(i)S
f7_10 sf
.096 .01( to the value of the delete flag of the event pointed to by )J
f11_10 sf
.035(evptr)A
f7_10 sf
(.)S
126 425 :M
f11_10 sf
-.073(j = EventGetType\(evptr\);)A
162 442 :M
f7_10 sf
.217 .022(This sets the integer )J
f11_10 sf
(j)S
f7_10 sf
.177 .018( to the type of the event pointed to by )J
f11_10 sf
.075(evptr.)A
126 465 :M
-.014(eventbody\(\)  {)A
162 482 :M
.079 .008(switch \(EventGetState\(\)\)  {)J
162 493 :M
-.137(Case 0:)A
198 504 :M
-.036(statement1)A
198 515 :M
.234 .023(EventReschedTime\(3.0, 1\))J
198 526 :M
-.387(return;)A
162 537 :M
-.137(Case 1;)A
198 548 :M
-.036(statement2)A
198 559 :M
-.039(EventReschedSema\(sptr, 2\))A
198 570 :M
-.387(return;)A
162 581 :M
-.137(Case 2:)A
198 592 :M
-.036(statement3)A
198 603 :M
-.06(EventSetDelFlag\(\))A
198 614 :M
-.387(return;)A
162 625 :M
(})S
126 636 :M
(})S
162 647 :M
f7_10 sf
.164 .016(An event using this function as its body would be similar to a process that)J
180 658 :M
.5(1.)A
198 658 :M
-.039(executes statement1,)A
180 669 :M
.5(2.)A
198 669 :M
.243 .024(delays for 3.0 time units,)J
180 680 :M
.5(3.)A
198 680 :M
-.063(resumes and executes statement2,)A
180 691 :M
.5(4.)A
198 691 :M
.125 .012(waits at the semaphore pointed to by sptr,)J
180 702 :M
.5(5.)A
198 702 :M
-.063(resumes and executes statement3,)A
180 713 :M
.833 .083(6. )J
198 713 :M
-.015(terminates.)A
endp
%%Page: 21 21
%%BeginPageSetup
initializepage
(; page: 21 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.518(Activities)A
524 59 :M
2.658(18)A
88 63 -1 1 542 62 1 88 62 @a
162 81 :M
f7_10 sf
.065 .006(The event must be created as a non-deleting event.  The EventSetDelFlag\(\) operation)J
162 92 :M
-.002(causes the event to be deleted when it terminates the next time.)A
90 115 :M
f5_12 sf
.792(Comments:)A
90 139 :M
f7_12 sf
-.087(Although there are a number of differences between processes and events, probably the most)A
90 151 :M
-.116(important one is that events can be implemented more efficiently than processes.  This is)A
90 163 :M
-.088(because every process must have its own private stack, which must exist during the lifetime of)A
90 175 :M
-.088(the process.   This can severely limit the size of a simulation.)A
90 199 :M
-.107(The reason for including the event rescheduling operations is to give an event some of the)A
90 211 :M
-.062(appearances of a process.  While it is not nearly as powerful as a process, it does not need a)A
90 223 :M
-.107(separate stack.  The biggest limitation of this approach to using events is that they can not)A
90 235 :M
-.078(easily resume operation at a point within a subroutine called from the event's body.  A process)A
90 247 :M
-.121(can suspend anywhere and then easily resume execution at that point.  Another limitation is that)A
90 259 :M
-.07(the local variables of an event's body are not saved when the body returns, and static variables)A
90 271 :M
-.064(can not be used, since different events may use the same body.)A
endp
%%Page: 22 22
%%BeginPageSetup
initializepage
(; page: 22 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(19)A
262 86 :M
f9_18 sf
3.273 .327(3.  QUEUES)J
90 117 :M
f7_12 sf
-.07(Queues are used for two purposes, to synchronize activities and to model the use of resources)A
90 129 :M
-.062(by processes.  There are four types of queues used for synchronization: )A
f11_12 sf
-.074(semaphores)A
f7_12 sf
-.039(, )A
f11_12 sf
-.064(barriers)A
f7_12 sf
(,)S
90 141 :M
f11_12 sf
-.104(flags)A
f7_12 sf
-.098(, and )A
f11_12 sf
-.112(conditions)A
f7_12 sf
-.108(.  They all contain a simple queue in which an activity can wait until some)A
90 153 :M
-.064(synchronization condition holds.  You can use them to synchronize processes and events.)A
90 165 :M
-.088(Resources model the behavior of an activity when it requests service from a resource.  If the)A
90 177 :M
-.056(resource is busy when an activity requests service, that activity waits in the resource's queue.)A
90 201 :M
f9_12 sf
3.429 .343(3.1.  SEMAPHORES)J
90 225 :M
f7_12 sf
-.118(Each semaphore has a value and two special operations SemaphoreWait\(\) and)A
90 237 :M
-.081(SemaphoreSignal\(\).  When a process executes SemaphoreWait\(\) on a semaphore, there are two)A
90 249 :M
-.065(possible results.  First, if the value of the semaphore is greater than zero, that value is)A
90 261 :M
-.096(decremented and the process continues.  On the other hand, if the semaphore value is equal to)A
90 273 :M
-.038(zero, the process suspends and enters the semaphore's internal queue at its tail.  In this case,)A
90 285 :M
-.113(the value of the semaphore does not change.  You can only execute SemaphoreWait\(\) within)A
90 297 :M
-.064(the body of a process, because processes are the only activities that can suspend.)A
90 321 :M
-.105(You can signal a semaphore from anywhere within the code of a simulation.  The operation)A
90 333 :M
-.053(SemaphoreSignal\(\) first checks to see if there are any processes in the semaphore's queue.  If)A
90 345 :M
-.119(there are, it then removes the one at the head of the queue and restarts it at the point where it)A
90 357 :M
-.048(suspended, but does not change the value of the semaphore.  If there are no waiting processes,)A
90 369 :M
-.106(the only effect of SemaphoreSignal\(\) is to increment the value of the semaphore.  Since)A
90 381 :M
-.079(processes are removed from the head of a semaphore's queue and entered at its tail, the queue)A
90 393 :M
-.043(uses a FIFO queuing discipline.)A
90 417 :M
-.131(You can use the operation ActivitySchedSema\(\) to place an activity at the tail of a semaphore's)A
90 429 :M
-.099(queue.  Since ActivitySchedSema\(\) is an operation defined for all activities, its use for this)A
90 441 :M
-.017(purpose was explained in Section 2.1.)A
90 465 :M
f5_12 sf
.634(Operations:)A
90 489 :M
f11_12 sf
.334 .033(SEMAPHORE *NewSemaphore\(sname, i\))J
90 501 :M
-.331(char *sname;)A
90 513 :M
-.399(int i;)A
108 531 :M
f7_12 sf
.008 .001(This operation creates and returns a pointer to a new semaphore with name )J
f11_12 sf
(sname)S
f7_12 sf
( and)S
-1 -1 91 534 1 1 90 516 @b
108 543 :M
-.15(initial value )A
f11_12 sf
-.221(i.)A
-1 -1 91 546 1 1 90 533 @b
90 567 :M
-.092(int SemaphoreInit\(sptr, i\))A
90 579 :M
-.042(SEMAPHORE *sptr;)A
90 591 :M
-.399(int i;)A
108 609 :M
f7_12 sf
2.533 .253(This operation sets the value of the semaphore pointed to by )J
f11_12 sf
.692(sptr)A
f7_12 sf
.947 .095( to )J
f11_12 sf
.494(i)A
f7_12 sf
1.701 .17(, if the)J
-1 -1 91 612 1 1 90 594 @b
108 621 :M
.059 .006(semaphore's queue is empty.  Otherwise, it does not affect the status of the semaphore)J
-1 -1 91 624 1 1 90 611 @b
108 633 :M
.398 .04(in any way.  It returns the number of activities in the semaphore's queue.  Therefore,)J
-1 -1 91 636 1 1 90 623 @b
108 645 :M
-.065(the operation is successful if and only if it returns 0.)A
-1 -1 91 648 1 1 90 635 @b
90 669 :M
f11_12 sf
-.079(void SemaphoreSignal\(sptr\))A
90 681 :M
-.042(SEMAPHORE *sptr;)A
108 699 :M
f7_12 sf
-.117(This operation removes the activity at the head of the queue of the semaphore pointed to)A
-1 -1 91 702 1 1 90 684 @b
108 711 :M
.116 .012(by )J
f11_12 sf
.047(sptr)A
f7_12 sf
.143 .014(, if the queue is not empty.  If that activity is an event, it starts executing at the)J
-1 -1 91 714 1 1 90 701 @b
endp
%%Page: 23 23
%%BeginPageSetup
initializepage
(; page: 23 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(20)A
88 63 -1 1 542 62 1 88 62 @a
108 81 :M
f7_12 sf
1.041 .104(beginning of its body.  If the removed activity is a suspended process it continues)J
-1 -1 91 84 1 1 90 71 @b
108 93 :M
.698 .07(executing its body at the instruction after the instance of SemaphoreWait\(\) where it)J
-1 -1 91 96 1 1 90 83 @b
108 105 :M
2.514 .251(suspended.  If it is a process that entered the queue due to an invocation of)J
-1 -1 91 108 1 1 90 95 @b
108 117 :M
-.067(ActivitySchedSema\(\), it starts executing at the beginning of the process' body.   If there)A
-1 -1 91 120 1 1 90 107 @b
108 129 :M
-.109(are no activities in the queue, this operation increments the value of the semaphore.)A
-1 -1 91 132 1 1 90 119 @b
90 153 :M
f11_12 sf
-.043(void SemaphoreSet\(sptr\))A
90 165 :M
-.042(SEMAPHORE *sptr;)A
108 183 :M
f7_12 sf
-.103(This operation is similar to SemaphoreSignal\(\) in that it removes the activity at the head)A
-1 -1 91 186 1 1 90 168 @b
108 195 :M
1.748 .175(of the queue of the semaphore pointed to by )J
f11_12 sf
.51(sptr)A
f7_12 sf
1.549 .155( and treats it the same way as)J
-1 -1 91 198 1 1 90 185 @b
108 207 :M
.057 .006(SemeaphoreSignal\(\), if the queue is not empty.  However, instead of incrementing the)J
-1 -1 91 210 1 1 90 197 @b
108 219 :M
.556 .056(semaphore value if the queue is empty, this operation sets it to 1.  If its value was 1)J
-1 -1 91 222 1 1 90 209 @b
108 231 :M
-.029(before, it remains 1.  Therefore, this operation can be used to implement binary-valued)A
-1 -1 91 234 1 1 90 221 @b
108 243 :M
-.059(semaphores, since its value will be either 0 or 1.)A
-1 -1 91 246 1 1 90 233 @b
90 267 :M
f11_12 sf
-.085(void SemaphoreWait\(sptr\))A
90 279 :M
-.042(SEMAPHORE *sptr;)A
108 297 :M
f7_12 sf
1.147 .115(You can only use this operation within the body of a process.  If the value of the)J
-1 -1 91 300 1 1 90 282 @b
108 309 :M
-.059(semaphore pointed to by )A
f11_12 sf
-.054(sptr)A
f7_12 sf
-.053( is zero, this operation will suspend the calling process.  If)A
-1 -1 91 312 1 1 90 299 @b
108 321 :M
1.241 .124(the value of the semaphore is greater than zero, this operation will decrement the)J
-1 -1 91 324 1 1 90 311 @b
108 333 :M
-.059(semaphore's value and the process will continue executing.)A
-1 -1 91 336 1 1 90 323 @b
90 357 :M
f11_12 sf
-.195(int SemaphoreDecr\(sptr\))A
90 369 :M
-.042(SEMAPHORE *sptr;)A
108 387 :M
f7_12 sf
.032 .003(If the value of the semaphore pointed to by )J
f11_12 sf
(sptr)S
f7_12 sf
.029 .003( is greater than 0, it is decremented.  If)J
-1 -1 91 390 1 1 90 372 @b
108 399 :M
-.013(the value is equal to 0, it is left unchanged.  The operation returns the new value of the)A
-1 -1 91 402 1 1 90 389 @b
108 411 :M
(semaphore.)S
-1 -1 91 414 1 1 90 401 @b
90 435 :M
f11_12 sf
-.143(int SemaphoreValue\(sptr\))A
90 447 :M
-.042(SEMAPHORE *sptr;)A
108 465 :M
f7_12 sf
-.091(This operation returns the value of the semaphore pointed to by )A
f11_12 sf
-.088(sptr)A
f7_12 sf
(.)S
-1 -1 91 468 1 1 90 450 @b
90 489 :M
f11_12 sf
-.132(int SemaphoreWaiting\(sptr\))A
90 501 :M
-.042(SEMAPHORE *sptr;)A
108 519 :M
f7_12 sf
-.082(This operation returns the number of activities in the queue of the semaphore pointed to)A
-1 -1 91 522 1 1 90 504 @b
108 531 :M
.104 .01(by )J
f11_12 sf
.042(sptr)A
f7_12 sf
(.)S
-1 -1 91 534 1 1 90 521 @b
90 555 :M
f5_12 sf
.668(Examples:)A
126 579 :M
f11_10 sf
-.035(semptr = NewSemaphore\("sem.2", 4\);)A
162 596 :M
f7_10 sf
.53 .053(This statement sets )J
f11_10 sf
.153(semptr)A
f7_10 sf
.493 .049( to point to a new semaphore named "sem.2" with initial)J
162 607 :M
.203 .02(value 4.)J
126 630 :M
f11_10 sf
-.076(SemaphoreSignal\(semptr\);)A
162 647 :M
f7_10 sf
2.055 .206(This statement signals the semaphore pointed to by )J
f11_10 sf
.59(semptr)A
f7_10 sf
1.305 .13(.  If there are any)J
162 658 :M
.277 .028(activities in its queue, the one at the head is released.  If not, the semaphore value is)J
162 669 :M
-.174(incremented.)A
endp
%%Page: 24 24
%%BeginPageSetup
initializepage
(; page: 24 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(21)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
-.098(SemaphoreWait\(semptr\);)A
162 98 :M
f7_10 sf
.253 .025(This statement can only appear in the body of a process.  If the semaphore's value is)J
162 109 :M
.956 .096(greater than zero, this operation decrements the value, and the process continues.)J
162 120 :M
-.035(Otherwise, the process suspends and waits in the semaphore's queue.)A
90 143 :M
f5_12 sf
.792(Comments:)A
90 167 :M
f7_12 sf
-.11(SemaphoreWait\(\) and SemaphoreSignal\(\) are sometimes called P and V.  We have chosen not)A
90 179 :M
-.104(to use these names since they are not as descriptive of the actions they perform as)A
90 191 :M
-.087(SemaphoreSignal\(\) and SemaphoreWait\(\).)A
90 215 :M
f9_12 sf
3.637 .364(3.2.  BARRIERS)J
90 239 :M
f7_12 sf
-.131(Barriers implement the barrier synchronization operation found in many parallel programming)A
90 251 :M
-.067(languages and operating systems.  You can only use barriers to synchronize processes; you can)A
90 263 :M
-.086(not use them in any way with events.  Like semaphores, barriers have a value that determines)A
90 275 :M
-.071(whether a process that synchronizes on it will suspend or continue.  If the value of a barrier is)A
90 287 :M
f11_12 sf
-.072(k)A
f7_12 sf
-.057(, then )A
f11_12 sf
-.072(k)A
f7_12 sf
-.066( processes must perform a synchronization operation on the barrier before any of them)A
90 299 :M
-.096(can proceed.  It is used to guarantee that )A
f11_12 sf
-.112(k)A
f7_12 sf
-.103( concurrently executing processes all reach a)A
90 311 :M
-.082(synchronization point in their code before any one of them can progress further.)A
90 335 :M
f5_12 sf
.634(Operations:)A
90 359 :M
f11_12 sf
.29 .029(BARRIER *NewBarrier\(bname, i\))J
90 371 :M
-.361(char *bname;)A
90 383 :M
-.399(int i;)A
108 401 :M
f7_12 sf
.502 .05(This operation creates and returns a pointer to a new barrier.  It sets the name of the)J
-1 -1 91 404 1 1 90 386 @b
108 413 :M
-.111(newly created barrier to )A
f11_12 sf
-.152(bname)A
f7_12 sf
-.104( and its value to )A
f11_12 sf
-.079(i)A
f7_12 sf
(.)S
-1 -1 91 416 1 1 90 403 @b
90 437 :M
f11_12 sf
-.202(int BarrierInit\(bptr, i\))A
90 449 :M
.448 .045(BARRIER *bptr;)J
90 461 :M
-.399(int i;)A
108 479 :M
f7_12 sf
-.035(This operation sets the value of the barrier pointed to by )A
f11_12 sf
-.038(bptr)A
f7_12 sf
-.029( to )A
f11_12 sf
(i)S
f7_12 sf
-.036(, if its queue is empty.)A
-1 -1 91 482 1 1 90 464 @b
108 491 :M
-.009(Otherwise, it does not affect the status of the barrier in any way.  It returns the number)A
-1 -1 91 494 1 1 90 481 @b
108 503 :M
-.025(of processes in the barrier's queue.  Therefore, the operation is successful if and only if)A
-1 -1 91 506 1 1 90 493 @b
108 515 :M
(it returns 0.)S
-1 -1 91 518 1 1 90 505 @b
90 539 :M
f11_12 sf
-.109(void BarrierSync\(bptr\))A
90 551 :M
.448 .045(BARRIER *bptr;)J
108 569 :M
f7_12 sf
1.263 .126(You can only use this operation within the body of a process.  It puts the calling)J
-1 -1 91 572 1 1 90 554 @b
108 581 :M
-.065(process in the queue of the barrier pointed to by )A
f11_12 sf
-.069(bptr)A
f7_12 sf
-.068( and checks to see if the number of)A
-1 -1 91 584 1 1 90 571 @b
108 593 :M
-.018(processes in the queue is now equal to the barrier's value.  If it is, all processes waiting)A
-1 -1 91 596 1 1 90 583 @b
108 605 :M
1.143 .114(in the queue, including the calling process, are removed and restarted.  If not, the)J
-1 -1 91 608 1 1 90 595 @b
108 617 :M
(calling process suspends.)S
-1 -1 91 620 1 1 90 607 @b
90 641 :M
f11_12 sf
-.21(int BarrierNeeded\(bptr\))A
90 653 :M
.448 .045(BARRIER *bptr;)J
108 671 :M
f7_12 sf
1.657 .166(This function returns the number of additional of processes that must perform a)J
-1 -1 91 674 1 1 90 656 @b
108 683 :M
-.017(BarrierSync\(\) operation on the barrier pointed to by )A
f11_12 sf
-.017(bptr)A
f7_12 sf
-.016( before the barrier will release)A
-1 -1 91 686 1 1 90 673 @b
108 695 :M
4.517 .452(all waiting processes.  The value of the barrier pointed to by )J
f11_12 sf
1.418(bptr)A
f7_12 sf
2.599 .26( is)J
-1 -1 91 698 1 1 90 685 @b
108 707 :M
-.086(BarrierNeeded\(bptr\) + BarrierWaiting\(bptr\).)A
-1 -1 91 710 1 1 90 697 @b
endp
%%Page: 25 25
%%BeginPageSetup
initializepage
(; page: 25 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(22)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.245(int BarrierWaiting\(bptr\))A
90 93 :M
.448 .045(BARRIER *bptr;)J
108 111 :M
f7_12 sf
-.009(This is a function that returns the number of processes waiting at the barrier pointed to)A
-1 -1 91 114 1 1 90 96 @b
108 123 :M
1.432 .143(by )J
f11_12 sf
.621(bptr)A
f7_12 sf
1.675 .167(.  The value of the barrier pointed to by )J
f11_12 sf
.621(bptr)A
f7_12 sf
2.797 .28( is BarrierNeeded\(bptr\) +)J
-1 -1 91 126 1 1 90 113 @b
108 135 :M
-.097(BarrierWaiting\(bptr\).)A
-1 -1 91 138 1 1 90 125 @b
90 159 :M
f5_12 sf
.668(Examples:)A
126 183 :M
f11_10 sf
-.219(barptr = NewBarrier \("syncpt",4\);)A
162 200 :M
f7_10 sf
.201 .02(This creates a barrier named "syncpt" that can be used to synchronize four processes)J
162 211 :M
.28 .028(and sets barptr to point to it.)J
126 234 :M
f11_10 sf
-.267(i = BarrierInit\(barptr, 3\);)A
162 251 :M
f7_10 sf
.298 .03(This changes the number of processes that can synchronize on the barrier pointed to)J
162 262 :M
.546 .055(by )J
f11_10 sf
.242(barptr)A
f7_10 sf
.629 .063( to 3, if the barrier's queue is empty.  It has no effect on the barrier if its)J
162 273 :M
1.232 .123(queue is not empty.  The return value )J
f11_10 sf
.421 .042(i )J
f7_10 sf
1.247 .125(is set to the number of processes in the)J
162 284 :M
-.147(barrier's queue.)A
126 307 :M
f11_10 sf
-.337(BarrierSync\(barptr\);)A
162 324 :M
f7_10 sf
.162 .016(This must be executed from within the body of a process.  That process will suspend)J
162 335 :M
.234 .023(unless it is the k-th process to synchronize on the barrier, where k is the value of the)J
162 346 :M
-.014(barrier.  If it is, all waiting processes are released.)A
90 369 :M
f5_12 sf
.792(Comments:)A
90 393 :M
f7_12 sf
-.081(There is a form of non-determinism inherent in the BarrierSync\(\) operation.  To see this,)A
90 405 :M
-.109(assume that the barrier needs )A
f11_12 sf
-.077(i)A
f7_12 sf
-.112( more processes to execute a Sync\(\) operation before all waiting)A
90 417 :M
-.091(processes are released.  If more than )A
f11_12 sf
-.065(i)A
f7_12 sf
-.096( processes execute the Sync\(\) at the same simulation)A
90 429 :M
-.122(time, then the order in which the simulator actually executes these operations determines which)A
90 441 :M
-.078(processes will be released.   While there does not appear to be any obvious way to avoid this)A
90 453 :M
-.043(situation, the system could check for it and issue a warning message.  However, this is not)A
90 465 :M
-.06(done in the current version.)A
90 489 :M
-.083(Synchronization similar to barrier synchronization is possible by forking processes and waiting)A
90 501 :M
-.061(for them to terminate with the operation ProcessJoin\(\).  In one sense, this is more restrictive,)A
90 513 :M
-.062(since the processes must terminate before they can synchronize.  Using barriers, the processes)A
90 525 :M
-.101(can synchronize any number of times before they terminate.  You can also use barriers to)A
90 537 :M
-.066(synchronize non-terminating processes.  However you can use the fork-join synchronization)A
90 549 :M
-.062(with events as well as processes, while you can only use barrier synchronization with)A
90 561 :M
.114(processes.)A
90 585 :M
f9_12 sf
3.666 .367(3.3.  FLAGS)J
90 609 :M
f7_12 sf
-.108(Flags are similar to barriers in that they provide a way to make several processes wait at a)A
90 621 :M
-.082(synchronization point until something happens.  In a barrier, all waiting processes are released)A
90 633 :M
-.068(when the number of waiting processes equals the barrier value.  In a flag, all waiting processes)A
90 645 :M
-.084(are released by explicit operations on the flag.  There are two such operations, FlagSet\(\) and)A
90 657 :M
-.102(FlagRelease\(\).  These operations also control the state of the flag as explained in the following)A
90 669 :M
-.073(section on operations.  There are two possible states, )A
f11_12 sf
-.07(set)A
f7_12 sf
-.073( and )A
f11_12 sf
-.081(cleared)A
f7_12 sf
(.)S
90 693 :M
-.123(You can also use the operations ActivitySchedFlag\(\) and EventReschedFlag\(\) to place an)A
90 705 :M
-.105(activity at the tail of a flag's queue.   Since ActivitySchedFlag\(\) is an operation defined for all)A
90 717 :M
-.04(activities, its use for this purpose was explained in Section 2.1.)A
endp
%%Page: 26 26
%%BeginPageSetup
initializepage
(; page: 26 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(23)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f5_12 sf
.634(Operations:)A
90 105 :M
f11_12 sf
.24 .024(FLAG *NewFlag\(fname\))J
90 117 :M
-.301(char *fname;)A
108 135 :M
f7_12 sf
-.086(This operation creates and returns a pointer to a new flag.  It sets the name of the flag to)A
-1 -1 91 138 1 1 90 120 @b
108 147 :M
f11_12 sf
-.175(fname)A
f7_12 sf
-.125( and its state to )A
f11_12 sf
-.154(cleared)A
f7_12 sf
(.)S
-1 -1 91 150 1 1 90 137 @b
90 171 :M
f11_12 sf
-.128(void FlagWait\(fptr\))A
90 183 :M
-.032(FLAG *fptr;)A
108 201 :M
f7_12 sf
-.014(You can only invoke this operation within the body of a process.  If the flag pointed to)A
-1 -1 91 204 1 1 90 186 @b
108 213 :M
.136 .014(by )J
f11_12 sf
.051(fptr)A
f7_12 sf
.201 .02( is in the cleared state when this operation is executed, then the calling process)J
-1 -1 91 216 1 1 90 203 @b
108 225 :M
.884 .088(suspends and enters the tail of the flag's queue, and the flag remains in the cleared)J
-1 -1 91 228 1 1 90 215 @b
108 237 :M
.549 .055(state.  If the flag is in the set state, then the calling process continues and the flag is)J
-1 -1 91 240 1 1 90 227 @b
108 249 :M
-.09(cleared.)A
-1 -1 91 252 1 1 90 239 @b
90 273 :M
f11_12 sf
-.145(int FlagSet\(fptr\))A
90 285 :M
-.032(FLAG *fptr;)A
108 303 :M
f7_12 sf
.006 .001(This operation sets the flag pointed to by )J
f11_12 sf
(fptr)S
f7_12 sf
.005 .001(.  Then, if there are any activities waiting)J
-1 -1 91 306 1 1 90 288 @b
108 315 :M
.031 .003(in the flag's queue, they are removed from the queue and scheduled for execution, and)J
-1 -1 91 318 1 1 90 305 @b
108 327 :M
.316 .032(the flag is cleared.  If there are no waiting activities, the flag remains set.  The return)J
-1 -1 91 330 1 1 90 317 @b
108 339 :M
-.117(value is the number of activities released.)A
-1 -1 91 342 1 1 90 329 @b
90 363 :M
f11_12 sf
-.198(int FlagRelease\(fptr\))A
90 375 :M
-.032(FLAG *fptr;)A
108 393 :M
f7_12 sf
-.006(This operation is similar to FlagSet\(\).  Its execution releases any waiting activities and)A
-1 -1 91 396 1 1 90 378 @b
108 405 :M
.659 .066(clears the flag.  However, if there are no waiting activities, FlagRelease\(\) clears the)J
-1 -1 91 408 1 1 90 395 @b
108 417 :M
-.08(flag, while FlagSet\(\) sets it.  The return value is the number of activities released.)A
-1 -1 91 420 1 1 90 407 @b
90 441 :M
f11_12 sf
-.182(int FlagWaiting\(fptr\))A
90 453 :M
-.032(FLAG *fptr;)A
108 471 :M
f7_12 sf
.474 .047(This operation returns the number of activities in the queue of the flag pointed to by)J
-1 -1 91 474 1 1 90 456 @b
108 483 :M
f11_12 sf
.142(fptr)A
f7_12 sf
(.)S
-1 -1 91 486 1 1 90 473 @b
90 507 :M
f5_12 sf
.668(Examples:)A
126 531 :M
f11_10 sf
-.179(flagptr = NewFlag\("F1"\);)A
162 548 :M
f7_10 sf
.136 .014(This creates a new flag with name "F1" and sets )J
f11_10 sf
.04(flagptr)A
f7_10 sf
.102 .01( to point to it.)J
126 571 :M
f11_10 sf
-.175(FlagWait\(flagptr\);)A
162 588 :M
f7_10 sf
.323 .032(This statement is only valid within the body of a process.  It suspends the process if)J
162 599 :M
.175 .017(the flag pointed to by )J
f11_10 sf
.056(flagptr)A
f7_10 sf
.151 .015( is in the cleared state.  If that flag is in the set state, the)J
162 610 :M
-.007(process continues, and flag is put in the cleared state.)A
126 633 :M
f11_10 sf
-.144(FlagSet\(flagptr\);)A
162 650 :M
f7_10 sf
.699 .07(This operation sets the flag pointed to by )J
f11_10 sf
.201(flagptr)A
f7_10 sf
.65 .065(.  Then, if there are any activities)J
162 661 :M
.311 .031(waiting at that flag, they are released and the flag is cleared.  If there are no waiting)J
162 672 :M
.192 .019(activities, the flag remains set.)J
endp
%%Page: 27 27
%%BeginPageSetup
initializepage
(; page: 27 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(24)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
-.209(FlagRelease\(flagptr\);)A
162 98 :M
f7_10 sf
.042 .004(This operation clears the flag pointed to by )J
f11_10 sf
.012(flagptr)A
f7_10 sf
.039 .004(.  If there are any activities waiting)J
162 109 :M
.266 .027(at the flag, they are released.  Note that the state of the flag is always clear after this)J
162 120 :M
-.071(operation is performed.)A
90 143 :M
f5_12 sf
.792(Comments:)A
90 167 :M
f7_12 sf
-.111(Some simulators and parallel programming languages use the term "event" instead of "flag")A
90 179 :M
-.067(and the term "post" for the operation FlagSet\(\).  Then, to say that "a process waits until an)A
90 191 :M
-.075(event is posted" is the same as saying that "a process waits until a flag is set."  Since the)A
90 203 :M
-.125(activity we call an event is a central YACSIM concept, we have chosen to use the less)A
90 215 :M
-.121(conventional term "flag" to describe the synchronization primitive.)A
90 239 :M
-.121(The operations FlagSet\(\) and FlagRelease\(\) have similar effects on a flag; either one will)A
90 251 :M
-.101(release processes that are waiting at the flag when it is applied.  The difference occurs when)A
90 263 :M
-.054(you apply them to a flag with no waiting processes.  In this case, FlagSet\(\) is remembered,)A
90 275 :M
-.09(while FlagRelease\(\) is not.  Consider the application of FlagSet\(\) to a flag with no waiting)A
90 287 :M
-.043(processes.  If a process then invokes FlagWait\(\) on that flag, it will not suspend, since it finds)A
90 299 :M
-.076(the flag set.  If you apply FlagRelease\(\) instead of FlagSet\(\), a following FlagWait\(\) will)A
90 311 :M
-.055(suspend its calling process, since FlagRelease\(\) does not set the flag.)A
90 335 :M
-.094(When the simulator runs on a uniprocessor host and several flag operations are scheduled at the)A
90 347 :M
-.091(same time, non-deterministic behavior is possible.   Since FlagSet\(\) and FlagRelease\(\) take)A
90 359 :M
-.132(effect at the point they are actually executed, a process that waits on a flag at the same)A
90 371 :M
-.134(simulation time the flag is released would depend on the order that the host actually executed)A
90 383 :M
-.093(the operations.  The process will suspend if FlagWait\(\) is executed after FlagRelease\(\) and will)A
90 395 :M
-.097(not suspend if they are executed in the opposite order.  We observe a similar effect if both)A
90 407 :M
-.121(FlagSet\(\) and FlagRelease\(\) execute at the same simulation time.  Whether or not the flag is set)A
90 419 :M
-.077(will depend on the order of execution of the two operations.)A
90 443 :M
f9_12 sf
2.745 .275(3.4.  CONDITIONS AND STATE VARIABLES)J
90 467 :M
f7_12 sf
-.087(Conditions offer another way to synchronize the execution of processes and schedule activities.)A
90 479 :M
-.106(You assign a logical expression to each condition when it is created.  When you later schedule)A
90 491 :M
-.115(an activity on a condition, the value of its associated expression determines when the activity)A
90 503 :M
-.075(takes place.  If the expression is true, we say that the condition holds, and the activity takes)A
90 515 :M
-.112(place at the current simulation time.  If the value of the expression is false, the activity is)A
90 527 :M
-.061(delayed in the condition's queue until the expression becomes true.  Similarly, when a process)A
90 539 :M
-.059(waits on a condition, it continues if the condition holds and suspends otherwise.  When a)A
90 551 :M
-.116(condition changes value from false to true, all waiting activities are released.)A
90 575 :M
-.12(We call the variables used in a condition's logical expression )A
f11_12 sf
-.118(state variables.)A
f7_12 sf
-.128(  They are special)A
90 587 :M
-.095(in that whenever one changes value, all conditions that use it are reevaluated.  If an expression)A
90 599 :M
-.124(evaluates true and there are activities waiting, they are released.)A
89 623 :M
f9_12 sf
3.403 .34(3.4.1.  State Variables)J
90 647 :M
f7_12 sf
-.094(There are two types of state variables, those with integer values and those with floating point)A
90 659 :M
-.088(values.  You must use the special operations provided below to access and change the values of)A
90 671 :M
-.134(state variables.  The statements that change the value of a state variable have a side effect of)A
90 683 :M
-.132(causing all conditions that depend on that state variable to be reevaluated.)A
endp
%%Page: 28 28
%%BeginPageSetup
initializepage
(; page: 28 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(25)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.131(There is one pre-defined floating point state variable that always equals the current simulation)A
90 93 :M
-.123(time.  SIMTIME is defined as a pointer that points to this state variable and is always available)A
90 105 :M
-.128(to the user.  The state variable pointed to by SIMTIME is updated automatically whenever)A
90 117 :M
-.122(simulation time is advanced.)A
90 141 :M
f5_12 sf
.634(Operations:)A
90 165 :M
f11_12 sf
.634 .063(IVAR *NewIvar\(ivname, i\))J
90 177 :M
-.303(char *ivname;)A
90 189 :M
-.399(int i;)A
108 207 :M
f7_12 sf
.232 .023(This operation creates and returns a pointer to a new integer state variable.  It assigns)J
-1 -1 91 210 1 1 90 192 @b
108 219 :M
-.152(the state variable the name )A
f11_12 sf
-.188(ivname)A
f7_12 sf
-.143( and the initial value )A
f11_12 sf
-.206(i.)A
-1 -1 91 222 1 1 90 209 @b
90 243 :M
.944 .094(FVAR *NewFvar\(fvname, x\))J
90 255 :M
-.22(char *fvname;)A
90 267 :M
-.122(double x;)A
108 285 :M
f7_12 sf
.486 .049(This operation creates and returns a pointer to a new floating point state variable.  It)J
-1 -1 91 288 1 1 90 270 @b
108 297 :M
-.098(assigns the state variable the name )A
f11_12 sf
-.112(fvname )A
f7_12 sf
-.093(and the initial value )A
f11_12 sf
-.174(x.)A
-1 -1 91 300 1 1 90 287 @b
90 321 :M
(void Iset\(ivptr, i\))S
90 333 :M
.172 .017(IVAR *ivptr;)J
90 345 :M
-.399(int i;)A
108 363 :M
f7_12 sf
-.113(This operation sets the value of the integer state variable pointed to by )A
f11_12 sf
-.112(ivptr)A
f7_12 sf
-.09(  to )A
f11_12 sf
-.082(i)A
f7_12 sf
(.)S
-1 -1 91 366 1 1 90 348 @b
90 387 :M
f11_12 sf
.45 .045(void Fset\(fvptr, x\))J
90 399 :M
.488 .049(FVAR *fvptr;)J
90 411 :M
-.122(double x;)A
108 429 :M
f7_12 sf
-.079(This operation sets the value of the floating point state variable pointed to by )A
f11_12 sf
-.078(fvptr)A
f7_12 sf
-.063(  to )A
f11_12 sf
-.142(x.)A
-1 -1 91 432 1 1 90 414 @b
108 441 :M
f7_12 sf
1.56 .156(The user should not attempt to set the special state variable SIMTIME with this)J
-1 -1 91 444 1 1 90 431 @b
108 453 :M
-.046(command.)A
-1 -1 91 456 1 1 90 443 @b
90 477 :M
f11_12 sf
-.141(int Ival\(ivptr\))A
90 489 :M
.172 .017(IVAR *ivptr;)J
108 507 :M
f7_12 sf
-.111(This operation returns the value of the integer state variable pointed to by )A
f11_12 sf
-.109(ivptr)A
f7_12 sf
(.)S
-1 -1 91 510 1 1 90 492 @b
90 531 :M
f11_12 sf
-.076(double Fval\(fvptr\))A
90 543 :M
.488 .049(FVAR *fvptr;)J
108 561 :M
f7_12 sf
-.099(This operation returns the value of the floating point state variable pointed to by )A
f11_12 sf
-.097(fvptr)A
f7_12 sf
(.)S
-1 -1 91 564 1 1 90 546 @b
90 585 :M
f5_12 sf
.668(Examples:)A
126 609 :M
f11_10 sf
-.045(iv = NewIvar\("iv1", 0\);)A
162 626 :M
f7_10 sf
.019 .002(Creates a new integer state variable and sets its value to 0.)J
126 649 :M
f11_10 sf
-.012(fv = NewFvar\("fv1", 0.0\);)A
162 666 :M
f7_10 sf
.128 .013(Creates a new floating point state variable and sets its value to 0.0.)J
126 689 :M
f11_10 sf
.472 .047(Fset\(fv, 4.5\);)J
162 706 :M
f7_10 sf
.338 .034(Sets the floating point state variable pointed to by )J
f11_10 sf
.087(fv)A
f7_10 sf
.247 .025( to 4.5.)J
endp
%%Page: 29 29
%%BeginPageSetup
initializepage
(; page: 29 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(26)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
-.04(Iset\(iv, Ival\(iv\)+3\);)A
162 98 :M
f7_10 sf
.105 .011(Increments the integer state variable pointed to by )J
f11_10 sf
(iv)S
f7_10 sf
.062 .006( by 3.)J
89 121 :M
f9_12 sf
4.593 .459(3.4.2.  Conditions)J
90 145 :M
f7_12 sf
-.076(You must use two statements to define a condition, one to define its expression, and one to)A
90 157 :M
-.088(name it and link it to its expression.  The expression is specified as a C function that returns a)A
90 169 :M
-.132(logical value \(actually an integer in C\) and has the following form:)A
198 193 :M
-.058(int )A
f11_12 sf
-.091(exname)A
f7_12 sf
-.071(\(argptr, argsize\))A
198 205 :M
-.135(char *argptr;)A
198 217 :M
-.18(int argsize;)A
198 229 :M
-.098({  statements; return \()A
f11_12 sf
-.115(expr)A
f7_12 sf
-.104(\); };)A
90 253 :M
-.07(where )A
f11_12 sf
-.079(exname)A
f7_12 sf
-.06( is an arbitrary name you assign to the expression.  )A
f11_12 sf
-.076(Expr)A
f7_12 sf
-.067( can be any expression)A
90 265 :M
-.128(that evaluates to true or false.  The arguments )A
f11_12 sf
-.142(argptr)A
f7_12 sf
-.129( and )A
f11_12 sf
-.137(argsize)A
f7_12 sf
-.131( are optional.  They are set)A
90 277 :M
-.107(when the condition is created or by the operation ConditionSetArg\(\).  They are intended to be)A
90 289 :M
-.049(used for passing arguments to the condition's expression is much the same way as arguments)A
90 301 :M
-.047(are passed to the body of a process or an event.)A
90 325 :M
f5_12 sf
.634(Operations:)A
90 349 :M
f11_12 sf
.563 .056(CONDITION *NewCondition\(cname, exname, sv1, ..., svn, NULL, argptr, argsize\))J
90 361 :M
-.391(char *cname;)A
90 373 :M
-.178(cond exname;)A
90 385 :M
1.676 .168(STVAR *sv1;)J
112 396 :M
.652 .065(.  .  .)J
90 413 :M
2.287 .229(STVAR *svn)J
90 425 :M
-.514(char argptr;)A
90 437 :M
-.302(int argsize;)A
108 455 :M
f7_12 sf
.71 .071(This operation creates and returns a pointer to a new condition.  The first argument)J
-1 -1 91 458 1 1 90 440 @b
108 467 :M
f11_12 sf
.189(cname)A
f7_12 sf
.527 .053( names the condition.  The second argument )J
f11_12 sf
.184(exname)A
f7_12 sf
.472 .047( links the condition to its)J
-1 -1 91 470 1 1 90 457 @b
108 479 :M
.095 .009(expression.  )J
f11_12 sf
.101 .01(Cond )J
f7_12 sf
.089 .009(is a typedef for the expression function described above.  That is, it)J
-1 -1 91 482 1 1 90 469 @b
108 491 :M
1.462 .146(is the name of an integer valued function that returns the value of an expression)J
-1 -1 91 494 1 1 90 481 @b
108 503 :M
-.098(involving state variables.  The arguments following the first two are pointers to the state)A
-1 -1 91 506 1 1 90 493 @b
108 515 :M
-.032(variables used in the expression )A
f11_12 sf
-.041(exname)A
f7_12 sf
-.032(.  The list of state variables must be terminated)A
-1 -1 91 518 1 1 90 505 @b
108 527 :M
.705 .07(with a null pointer.  You must list pointers to all state variables that are used in the)J
-1 -1 91 530 1 1 90 517 @b
108 539 :M
-.059(expression as arguments to CONDITION, and you must end with the argument NULL.)A
-1 -1 91 542 1 1 90 529 @b
108 551 :M
.397 .04(This is required so that the condition can establish links with its state variables.  The)J
-1 -1 91 554 1 1 90 541 @b
108 563 :M
.365 .037(last two arguments are passed to the expression that defines the condition every time)J
-1 -1 91 566 1 1 90 553 @b
108 575 :M
.375 .038(that expression is reevaluated.  For an expression named )J
f11_12 sf
.123(exname)A
f7_12 sf
.151 .015( on )J
f11_12 sf
.121(n)A
f7_12 sf
.41 .041( state variables)J
-1 -1 91 578 1 1 90 565 @b
108 587 :M
-.108(and a condition named )A
f11_12 sf
-.131(condname)A
f7_12 sf
-.103(, this operation would be called in the following way:)A
-1 -1 91 590 1 1 90 577 @b
162 605 :M
.447 .045(NewCondition\(condname, exname, sv1, sv2, ... , svn, NULL, aptr, asize\))J
-1 -1 91 608 1 1 90 590 @b
108 623 :M
1.797 .18(where )J
f11_12 sf
1.176 .118(sv1, sv2, ... , svn)J
f7_12 sf
1.52 .152( are pointers to the state variables used in the expression)J
-1 -1 91 626 1 1 90 608 @b
108 635 :M
f11_12 sf
-.046(exname)A
f7_12 sf
-.037(.  Note that the state variable names and the expression name must be visible to)A
-1 -1 91 638 1 1 90 625 @b
108 647 :M
-.032(this operation.  The easiest way to guarantee this is to declare them as global variables.)A
-1 -1 91 650 1 1 90 637 @b
108 659 :M
.528 .053(Also, all state variables referenced in the NewCondition\(\) operation must be created)J
-1 -1 91 662 1 1 90 649 @b
108 671 :M
-.09(prior to the execution of this operation.)A
-1 -1 91 674 1 1 90 661 @b
endp
%%Page: 30 30
%%BeginPageSetup
initializepage
(; page: 30 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(27)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.115(void ConditionWait\(cptr\))A
90 93 :M
-.132(CONDITION *cptr;)A
108 111 :M
f7_12 sf
.461 .046(If the condition pointed to by )J
f11_12 sf
.141(cptr)A
f7_12 sf
.54 .054( holds when this operation is executed, the calling)J
-1 -1 91 114 1 1 90 96 @b
108 123 :M
-.002(process continues.  If it does not hold, then the calling process suspends and enters the)A
-1 -1 91 126 1 1 90 113 @b
108 135 :M
.146 .015(tail of the condition's queue.  You can only invoke this operation within the body of a)J
-1 -1 91 138 1 1 90 125 @b
108 147 :M
.146(process.)A
-1 -1 91 150 1 1 90 137 @b
90 171 :M
f11_12 sf
-.173(int ConditionState\(cptr\))A
90 183 :M
-.132(CONDITION *cptr;)A
108 201 :M
f7_12 sf
.73 .073(This operation returns the status of the condition pointed to by )J
f11_12 sf
.204(cptr)A
f7_12 sf
.582 .058(.  There are two)J
-1 -1 91 204 1 1 90 186 @b
108 213 :M
.235 .023(possible values: FALSE \(i.e., 0\) and TRUE \(i.e., 1\).)J
-1 -1 91 216 1 1 90 203 @b
90 237 :M
f11_12 sf
-.159(int ConditionWaiting\(cptr\))A
90 249 :M
-.132(CONDITION *cptr;)A
108 267 :M
f7_12 sf
-.006(This operation returns the number of activities in the queue of the condition pointed to)A
-1 -1 91 270 1 1 90 252 @b
108 279 :M
-.044(by )A
f11_12 sf
-.042(cptr)A
f7_12 sf
(.)S
-1 -1 91 282 1 1 90 269 @b
90 303 :M
f11_12 sf
-.069(void ConditionSetArg\(cptr, aptr, asize\))A
90 315 :M
-.132(CONDITION *cptr;)A
90 327 :M
-.499(char *aptr;)A
90 339 :M
-.295(int asize;)A
108 357 :M
f7_12 sf
1.091 .109(This saves the pointer )J
f11_12 sf
.318(aptr)A
f7_12 sf
.864 .086( and the integer )J
f11_12 sf
.306(asize)A
f7_12 sf
1.084 .108( in the descriptor of the condition)J
-1 -1 91 360 1 1 90 342 @b
108 369 :M
1.091 .109(pointed to by )J
f11_12 sf
.35(cptr)A
f7_12 sf
1.182 .118(.  They are passed to the condition's expression every time it is)J
-1 -1 91 372 1 1 90 359 @b
108 381 :M
1.565 .156(evaluated.  These arguments can also be set when the NewCondition\(\) is called.)J
-1 -1 91 384 1 1 90 371 @b
108 393 :M
.409 .041(ConditionSetArg\(\) provides a way of changing the arguments after the condition has)J
-1 -1 91 396 1 1 90 383 @b
108 405 :M
.874 .087(been created.  Note that this operation only passes a pointer to the condition, not a)J
-1 -1 91 408 1 1 90 395 @b
108 417 :M
-.039(value.  Therefore, when the condition's expression accesses the argument pointed to by)A
-1 -1 91 420 1 1 90 407 @b
108 429 :M
-.05(this pointer, it will get the value of the argument at the time it is accessed, and this may)A
-1 -1 91 432 1 1 90 419 @b
108 441 :M
-.078(not be the same as its value when the argument was set.)A
-1 -1 91 444 1 1 90 431 @b
90 465 :M
f5_12 sf
.668(Examples:)A
126 489 :M
f11_10 sf
.229 .023(int contest\(nullptr, i\))J
126 500 :M
-.183(char *nullptr;)A
126 511 :M
.558 .056(int i;)J
126 522 :M
-.167({ return \(Ival\(ivptr[i]\) != 0\); };)A
126 533 :M
.259 .026(cptr1 = NewCondition\("con", contest, ivptr, NULL, NULL, 4\);)J
162 550 :M
f7_10 sf
.509 .051(The condition )J
f11_10 sf
.143(con)A
f7_10 sf
.347 .035( will hold if and only if the state variable pointed to by )J
f11_10 sf
.109(ivptr[i])A
f7_10 sf
.227 .023( is)J
162 561 :M
.141 .014(not equal to zero.  The first argument to contest is not used, but the second is used to)J
162 572 :M
-.032(select one state variable from an array of state variables.)A
126 595 :M
f11_10 sf
-.057(int expr1\(\){ return \(\(Fval\(x\) > Fval\(y\)\) && \(Fval\(y\) != 2.43\)\); };)A
126 606 :M
.422 .042(cptr2 = NewCondition\("C1", expr1, x, y, NULL, NULL, 0\);)J
162 623 :M
f7_10 sf
.248 .025(The condition )J
f11_10 sf
.084(C1)A
f7_10 sf
.162 .016( will hold if and only if the state variable  pointed to by )J
f11_10 sf
.064(x)A
f7_10 sf
.19 .019( is greater)J
162 634 :M
.51 .051(than the state variable  pointed to by )J
f11_10 sf
.182(y)A
f7_10 sf
.509 .051(, and the state variable pointed to by )J
f11_10 sf
.182(y)A
f7_10 sf
.386 .039( is not)J
162 645 :M
.145 .014(equal to 2.43.  A NULL argptr and arsize of 0 are passed to NewCondition\(\), but not)J
162 656 :M
-.047(used by contest\(\).)A
endp
%%Page: 31 31
%%BeginPageSetup
initializepage
(; page: 31 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(28)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
-.021(Iset\(ivptr, 1\);)A
126 92 :M
-.087(ConditionWait\(cptr1\))A
162 109 :M
f7_10 sf
.277 .028(If )J
f11_10 sf
.149(ivptr)A
f7_10 sf
.306 .031( and )J
f11_10 sf
.166(cptr1)A
f7_10 sf
.67 .067( are as defined above, then the process invoking ConditionWait\(\))J
162 120 :M
.066 .007(will not suspend because the condition holds.  If we had set the state variable pointed)J
162 131 :M
.046 .005(to by )J
f11_10 sf
.02(ivptr)A
f7_10 sf
.085 .009( to 0, the process would suspend when it invoked ConditionWait\(\).)J
126 154 :M
f11_10 sf
-.162(i = CondStatus\(condptr\);)A
162 171 :M
f7_10 sf
.144 .014(This statement sets the integer )J
f11_10 sf
(i)S
f7_10 sf
.114 .011( to the status of the condition pointed to by )J
f11_10 sf
.042(condptr)A
f7_10 sf
(.)S
90 194 :M
f5_12 sf
.792(Comments:)A
90 218 :M
f7_12 sf
-.108(The reason for declaring the expression separately from the condition is to avoid a)A
90 230 :M
-.073(preprocessing step that would be needed to parse the expression.  Implementing it this way, the)A
90 242 :M
-.06(C compiler does the parsing.)A
90 266 :M
-.113(The last two arguments to the operation NewCondition\(\) can probably to omitted if they are not)A
90 278 :M
-.033(used within the condition's expression.  NewCondition\(\) will look for them on the stack, save)A
90 290 :M
-.069(whatever it finds there in its descriptor, and pass them to the condition's expression every time)A
90 302 :M
-.103(the condition is evaluated.  If they are omitted, NewCondition will load garbage in the)A
90 314 :M
-.036(descriptor and pass it to the expression.  However, if the expression does not use or even)A
90 326 :M
-.074(declare its arguments, no harm is done.  This would mean that the arguments passed to)A
90 338 :M
-.118(NewCondition do not match its declared arguments, and there is some chance that an attempt to)A
90 350 :M
-.084(access them would result in a segmentation fault.  Probably the safest thing to do is to always)A
90 362 :M
-.058(pass the last two arguments to NewCondition whether they are used by the expression or not.)A
90 386 :M
-.119(Conditions are reevaluated each time one of their state variables changes value.  This introduces)A
90 398 :M
-.106(a form of non-deterministic behavior.  Indeed, if several statements executing at the same)A
90 410 :M
-.133(simulation time can alter the state of a condition, the behavior of the simulation could depend)A
90 422 :M
-.123(on the order that the simulator actually executes the statements.  This situation can only happen)A
90 434 :M
-.137(if a state variable experiences several changes at the same simulation time, and simulations that)A
90 446 :M
-.086(do this are probably inherently non-deterministic.  Therefore, the simulator should probably)A
90 458 :M
-.091(issue a warning message when this happens, since it is likely to be a mistake in the simulation)A
90 470 :M
-.094(program.  This is not yet implemented in the current version of YACSIM.)A
90 494 :M
f9_12 sf
3.725 .372(3.5.  RESOURCES)J
90 518 :M
f7_12 sf
-.085(A resource consists of a queue and a set of servers.  The only thing that an activity can do with)A
90 530 :M
-.088(a resource is to request service time.  When an activity makes a request, the resource assigns it)A
90 542 :M
-.072(to a free server, if one is available, and puts it in the queue otherwise.  A resource makes no)A
90 554 :M
-.099(distinction among its different servers and simply picks the first free one it can find to satisfy a)A
90 566 :M
-.079(request for service.  The activity is in a suspended state when it requests service and does not)A
90 578 :M
-.077(wake up until its request has been fulfilled.  When a server finishes serving an activity, it looks)A
90 590 :M
-.089(for another activity in the queue to serve.  If there are none it returns to a pool of free servers)A
90 602 :M
-.076(and waits for another activity to serve.  The set of rules used to decide how the resource puts)A
90 614 :M
-.127(activities in its queue and takes them out for service is called the )A
f11_12 sf
-.137(queuing discipline)A
f7_12 sf
-.138( for the)A
90 626 :M
-.094(resource.  Most of the standard queuing disciplines have been implemented.  They are)A
90 638 :M
-.095(described later in this section.)A
endp
%%Page: 32 32
%%BeginPageSetup
initializepage
(; page: 32 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(29)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f5_12 sf
.634(Operations:)A
90 105 :M
f11_12 sf
.276 .028(RESOURCE *NewResource\(rname, qdisc, nserv, slice\))J
90 117 :M
-.422(char *rname;)A
90 129 :M
-.221(int qdisc;)A
90 141 :M
-.183(int nserv;)A
90 153 :M
-.22(double slice;)A
108 171 :M
f7_12 sf
.204 .02(The operation creates and returns a pointer to a resource.  The argument )J
f11_12 sf
.076(qname)A
f7_12 sf
.131 .013( is the)J
-1 -1 91 174 1 1 90 156 @b
108 183 :M
1.219 .122(name assigned to the resource.  The argument )J
f11_12 sf
.346(qdisc)A
f7_12 sf
1.047 .105( is a integer that specifies the)J
-1 -1 91 186 1 1 90 173 @b
108 195 :M
-.032(queuing discipline for the resource to use.  The choices for this argument are described)A
-1 -1 91 198 1 1 90 185 @b
108 207 :M
.787 .079(in the following section.  )J
f11_12 sf
.277(Nserv)A
f7_12 sf
.744 .074( is the number of servers for the resource.  The last)J
-1 -1 91 210 1 1 90 197 @b
108 219 :M
-.088(argument )A
f11_12 sf
-.072(slice)A
f7_12 sf
-.082( is only used with the "round robin" and "round robin preemptive resume)A
-1 -1 91 222 1 1 90 209 @b
108 231 :M
.443 .044(with priority" queuing disciplines and is ignored for all others.  It is explained in the)J
-1 -1 91 234 1 1 90 221 @b
108 243 :M
-.066(following section on queuing disciplines.)A
-1 -1 91 246 1 1 90 233 @b
90 267 :M
f11_12 sf
-.064(void ResourceUse\(rptr, timeinc\))A
90 279 :M
-.094(RESOURCE *rptr;)A
90 291 :M
-.212(double timeinc;)A
108 309 :M
f7_12 sf
.162 .016(This is the operation a process uses to request service from the resource pointed to by)J
-1 -1 91 312 1 1 90 294 @b
108 321 :M
f11_12 sf
-.061(rptr)A
f7_12 sf
-.065(.  The argument )A
f11_12 sf
-.066(timeinc)A
f7_12 sf
-.064( is the amount of service time requested.  The operation can)A
-1 -1 91 324 1 1 90 311 @b
108 333 :M
-.038(only be invoked from within a process body.)A
-1 -1 91 336 1 1 90 323 @b
90 357 :M
f11_12 sf
-.165(int ResourceWaiting\(rptr\))A
90 369 :M
-.094(RESOURCE *rptr;)A
108 387 :M
f7_12 sf
.184 .018(This operation returns the number of activities in the queue of the resource pointed to)J
-1 -1 91 390 1 1 90 372 @b
108 399 :M
-.091(by )A
f11_12 sf
-.085(rptr)A
f7_12 sf
(.)S
-1 -1 91 402 1 1 90 389 @b
90 423 :M
f11_12 sf
-.126(int ResourceServicing\(rptr\))A
90 435 :M
-.094(RESOURCE *rptr;)A
108 453 :M
f7_12 sf
-.051(This operation returns the number of activities that are currently receiving service from)A
-1 -1 91 456 1 1 90 438 @b
108 465 :M
-.104(the resource pointed to by )A
f11_12 sf
-.103(rptr)A
f7_12 sf
(.)S
-1 -1 91 468 1 1 90 455 @b
90 489 :M
f5_12 sf
4.488 .449(Queuing Disciplines:)J
90 513 :M
f7_12 sf
-.088(Ten different queuing disciplines are implemented.  Currently, there is no way for the user to)A
90 525 :M
-.095(add new ones, although that capability may be added later.  The user specifies the queuing)A
90 537 :M
-.078(discipline for a resource by passing an integer code to the operation NewResource\(\).)A
90 549 :M
-.134(Abbreviated names have been defined for all the implemented disciplines, and these can be)A
90 561 :M
-.128(used in place of the integer code to improve readability.  These abbreviated names are listed in)A
90 573 :M
-.093(bold after the full names of the disciplines in the following descriptions.)A
90 597 :M
f11_12 sf
.076 .008(First Come First Served - )J
f9_12 sf
.045(FCFS)A
108 615 :M
f7_12 sf
.818 .082(The resource inserts processes into its queue at the tail and removes them from the)J
-1 -1 91 618 1 1 90 600 @b
108 627 :M
.414 .041(head.  Once the resource assigns a process to a server, that process receives all of its)J
-1 -1 91 630 1 1 90 617 @b
108 639 :M
-.086(requested service without interruption.)A
-1 -1 91 642 1 1 90 629 @b
90 663 :M
f11_12 sf
.323 .032(Last Come First Served )J
f9_12 sf
.439 .044(- LCFS)J
108 681 :M
f7_12 sf
.488 .049(The resource inserts processes into its queue at the head and removes them from the)J
-1 -1 91 684 1 1 90 666 @b
108 693 :M
.414 .041(head.  Once the resource assigns a process to a server, that process receives all of its)J
-1 -1 91 696 1 1 90 683 @b
108 705 :M
-.086(requested service without interruption.)A
-1 -1 91 708 1 1 90 695 @b
endp
%%Page: 33 33
%%BeginPageSetup
initializepage
(; page: 33 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(30)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
.055 .006(Last Come First Served Preemptive Resume - )J
f9_12 sf
.026(LCFSPR)A
108 99 :M
f7_12 sf
.178 .018(This discipline will only use one server no matter how many are specified.  When the)J
-1 -1 91 102 1 1 90 84 @b
108 111 :M
.819 .082(resource receives a request and its server is busy, it preempts the process receiving)J
-1 -1 91 114 1 1 90 101 @b
108 123 :M
.29 .029(service and lowers its requested time by the amount of service time already received.)J
-1 -1 91 126 1 1 90 113 @b
108 135 :M
.221 .022(The resource then puts the preempted process at the head of its queue and assigns the)J
-1 -1 91 138 1 1 90 125 @b
108 147 :M
.834 .083(new requesting process to the server.  When the server finishes with one process it)J
-1 -1 91 150 1 1 90 137 @b
108 159 :M
1.06 .106(takes the process from the head of the queue, if any, and proceeds to complete its)J
-1 -1 91 162 1 1 90 149 @b
108 171 :M
-.108(service time.)A
-1 -1 91 174 1 1 90 161 @b
90 195 :M
f11_12 sf
.005 0(First Come First Served Preemptive Resume With Priorities - )J
f5_12 sf
(FCFSPRWP)S
108 213 :M
f7_12 sf
.149 .015(This discipline will only use one server no matter how many are specified.  Users can)J
-1 -1 91 216 1 1 90 198 @b
108 225 :M
2.281 .228(assign priorities to processes using ProcessSetPriority\(\). This discipline uses a)J
-1 -1 91 228 1 1 90 215 @b
108 237 :M
1.537 .154(process' priority to determine where it should be inserted in the queue.  When a)J
-1 -1 91 240 1 1 90 227 @b
108 249 :M
-.075(resource receives a request and its server is busy, it reacts in the following way:)A
-1 -1 91 252 1 1 90 239 @b
126 267 :M
(\245)S
144 267 :M
-.026(If the priority of the process being served is greater than or equal to the priority)A
-1 -1 91 270 1 1 90 252 @b
144 279 :M
-.019(of the new process requesting service, the resource inserts the new process into)A
-1 -1 91 282 1 1 90 269 @b
144 291 :M
-.059(the queue in the order of its priority and behind all other processes that have the)A
-1 -1 91 294 1 1 90 281 @b
144 303 :M
-.049(same priority.)A
-1 -1 91 306 1 1 90 293 @b
126 321 :M
(\245)S
144 321 :M
1.017 .102(If the process being served has lower priority, the resource preempts it and)J
-1 -1 91 324 1 1 90 306 @b
144 333 :M
.137 .014(lowers its requested time by the amount of service time already received.  The)J
-1 -1 91 336 1 1 90 323 @b
144 345 :M
1.065 .106(resource then inserts the preempted process in the queue in the order of its)J
-1 -1 91 348 1 1 90 335 @b
144 357 :M
.066 .007(priority and in front of all other processes that have the same priority.  Finally,)J
-1 -1 91 360 1 1 90 347 @b
144 369 :M
-.047(the resource assigns the new requesting process to the server.)A
-1 -1 91 372 1 1 90 359 @b
108 387 :M
.74 .074(When the server finishes with one process it takes the process from the head of the)J
-1 -1 91 390 1 1 90 372 @b
108 399 :M
-.075(queue, if any, and proceeds to complete its service time.)A
-1 -1 91 402 1 1 90 389 @b
90 423 :M
f11_12 sf
-.017(Last Come First Served Preemptive Resume With Priorities - )A
f9_12 sf
-.032(LCFSPRWP)A
108 441 :M
f7_12 sf
-.054(This discipline is the same as the FCFSPRWP discipline described above, except that a)A
-1 -1 91 444 1 1 90 426 @b
108 453 :M
-.052(process requesting service is inserted in the queue in the order of its priority, in front of)A
-1 -1 91 456 1 1 90 443 @b
108 465 :M
-.089(all processes with the same priority instead of behind them.)A
-1 -1 91 468 1 1 90 455 @b
90 489 :M
f11_12 sf
.123 .012(Processor Sharing - )J
f9_12 sf
.06(PROCSHAR)A
108 507 :M
f7_12 sf
.584 .058(This discipline uses as many servers as it needs to service all request without delay.)J
-1 -1 91 510 1 1 90 492 @b
108 519 :M
-.089(That is, all processes start receiving service as soon as they request it and they are never)A
-1 -1 91 522 1 1 90 509 @b
108 531 :M
1.669 .167(delayed in a queue.  However, when there are k processes receiving service the)J
-1 -1 91 534 1 1 90 521 @b
108 543 :M
-.087(remaining service time for each is increased by a factor of k.  As processes arrive at and)A
-1 -1 91 546 1 1 90 533 @b
108 555 :M
.761 .076(leave the resource, the requested service time of each of the remaining processes is)J
-1 -1 91 558 1 1 90 545 @b
108 567 :M
-.095(altered to account for the new value of k.)A
-1 -1 91 570 1 1 90 557 @b
90 591 :M
f11_12 sf
.31 .031(Round Robin - )J
f9_12 sf
.324(RR)A
108 609 :M
f7_12 sf
1.291 .129(This queuing discipline is one of the two that use the )J
f11_12 sf
.366(slice)A
f7_12 sf
1.729 .173( argument.  Processes)J
-1 -1 91 612 1 1 90 594 @b
108 621 :M
.074 .007(requesting service are put at the tail of the queue.  Whenever there is a free server, the)J
-1 -1 91 624 1 1 90 611 @b
108 633 :M
-.017(resource takes the process from the head of the queue and assigns it to that server for a)A
-1 -1 91 636 1 1 90 623 @b
108 645 :M
-.017(service time equal to the slice time.  When a server completes a time slice the resource)A
-1 -1 91 648 1 1 90 635 @b
108 657 :M
.156 .016(reduces the process' requested service time by the slice amount and puts it back at the)J
-1 -1 91 660 1 1 90 647 @b
108 669 :M
1.039 .104(tail of its queue.  If the process taken from the head of the queue has a remaining)J
-1 -1 91 672 1 1 90 659 @b
108 681 :M
.422 .042(service request less than the slice time, the resource only assigns it to a server for its)J
-1 -1 91 684 1 1 90 671 @b
108 693 :M
-.123(remaining requested time.)A
-1 -1 91 696 1 1 90 683 @b
endp
%%Page: 34 34
%%BeginPageSetup
initializepage
(; page: 34 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(31)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
.481 .048(Random - )J
f9_12 sf
.322(RAND)A
108 99 :M
f7_12 sf
.788 .079(The resource inserts processes requesting service randomly into its queue.  When a)J
-1 -1 91 102 1 1 90 84 @b
108 111 :M
-.06(server is free, it starts serving the process at the head of the queue.)A
-1 -1 91 114 1 1 90 101 @b
90 135 :M
f11_12 sf
.412 .041(Shortest Job Next - )J
f9_12 sf
.278(SJN)A
108 153 :M
f7_12 sf
-.084(This discipline will only use one server no matter how many are specified.  Whenever a)A
-1 -1 91 156 1 1 90 138 @b
108 165 :M
1.587 .159(job finishes service, the shortest job \(i.e., the one with the smallest service time)J
-1 -1 91 168 1 1 90 155 @b
108 177 :M
-.112(request\) will be selected next to receive service from the resource.)A
-1 -1 91 180 1 1 90 167 @b
90 201 :M
f11_12 sf
.054 .005(Round Robin Preemptive Resume With Priority - )J
f9_12 sf
.028(RRPRWP)A
108 219 :M
f7_12 sf
.074 .007(This discipline will only use one server no matter how many are specified.  It uses the)J
-1 -1 91 222 1 1 90 204 @b
108 231 :M
.084 .008(round robin queuing discipline to service processes in its queue until a service request)J
-1 -1 91 234 1 1 90 221 @b
108 243 :M
.633 .063(is received.  It uses the )J
f11_12 sf
.213(slice)A
f7_12 sf
.837 .084( argument in the same way as the round robin queuing)J
-1 -1 91 246 1 1 90 233 @b
108 255 :M
-.025(discipline.  When a process requests service from the resource, its priority is compared)A
-1 -1 91 258 1 1 90 245 @b
108 267 :M
-.003(to the priority of the process currently receiving service.  If the new processes' priority)A
-1 -1 91 270 1 1 90 257 @b
108 279 :M
1.045 .104(is higher, it preempts the one receiving service.  Otherwise it enters the resource's)J
-1 -1 91 282 1 1 90 269 @b
108 291 :M
-.083(queue in the order of its priority, behind all other processes that have the same priority.)A
-1 -1 91 294 1 1 90 281 @b
90 315 :M
f5_12 sf
.762(Examples)A
126 339 :M
f11_12 sf
.347 .035(rsptr1 = NewResource\("Res 2", FCFS, 3, 0.0\))J
162 357 :M
f7_12 sf
.088 .009(This statement sets the pointer )J
f11_12 sf
.024(rsptr1)A
f7_12 sf
.078 .008( to a new resource named "Res 2")J
162 369 :M
1.123 .112(that has three servers and uses the First Come First Served queuing)J
162 381 :M
-.086(discipline.  The slice time is ignored.)A
126 405 :M
f11_12 sf
.492 .049(rsptr2 = NewResource\("Res 1", LCFSPRWP, 1, 0.0\))J
162 423 :M
f7_12 sf
1.781 .178(This declaration creates a resource, names it "Res 1", and sets its)J
162 435 :M
-.024(queuing discipline to Last Come First Served Preemptive Resume With)A
162 447 :M
.043(Priority.)A
126 471 :M
f11_12 sf
.41 .041(resptr3 =  NewResource\("RRrsc", RR, 9, 20.0\))J
162 489 :M
f7_12 sf
-.032(This resource uses the Round Robin queuing discipline, has 9 servers, a)A
162 501 :M
-.052(service slice of 20 time units, and is named "RRrsc.")A
126 525 :M
f11_12 sf
.277 .028(resptr4 =  NewResource\("PR", LCFSPR, 3, 5.0\);)J
162 543 :M
f7_12 sf
.189 .019(This statement creates a resource named "PR" that uses the Last Come)J
162 555 :M
.91 .091(First Served Preemptive Resume queuing discipline.  Note that even)J
162 567 :M
.216 .022(though the declaration specifies 3 servers and a time slice of 5.0, these)J
162 579 :M
1.024 .102(arguments will be ignored, because this discipline will only use one)J
162 591 :M
-.088(server and does not need a time slice.)A
126 615 :M
f11_12 sf
-.041(ResourceUse\(rptr, 25.0\);)A
162 633 :M
f7_12 sf
1.026 .103(This statement requests 25.0 time units of service from the resource)J
162 645 :M
-.017(pointed to by )A
f11_12 sf
-.017(rptr)A
f7_12 sf
-.018(.  The statement can only be executed from within the)A
162 657 :M
.149 .015(body of a process.)J
90 681 :M
f5_12 sf
.904(Comments)A
90 705 :M
f7_12 sf
-.11(The effect of the operation ResourceUse\(\) on a uniprocessor host is delayed until all activities)A
90 717 :M
-.113(scheduled at the same time have been initiated.  This means that, for the preemptive disciplines,)A
endp
%%Page: 35 35
%%BeginPageSetup
initializepage
(; page: 35 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.999(Queues)A
524 59 :M
2.658(32)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.102(if ResourceUse\(\) is invoked more than once at the same simulation time, it will be the process)A
90 93 :M
-.112(with highest priority that calls ResourceUse\(\) most recently in real time that gets service.)A
90 117 :M
f9_12 sf
3.264 .326(3.6.  QUEUE STATISTICS)J
90 141 :M
f7_12 sf
-.118(Statistics can be automatically collected on queues.  The following operations are used to)A
90 153 :M
-.129(activate this feature and to access the collected statistics.  Note that when a queue is deleted its)A
90 165 :M
-.096(associated statistics record is also deleted.)A
90 189 :M
f5_12 sf
3.497 .35( Operations:)J
90 213 :M
f11_12 sf
.101 .01(void QueueCollectStats\(qptr, type, meanflg, histflg, nbin, low, high\))J
90 225 :M
-.046(RESOURCE *qptr;)A
90 237 :M
-.206(int type;)A
90 249 :M
-.211(int meanflg;)A
90 261 :M
-.151(int histflg;)A
90 273 :M
-.249(int nbin;)A
90 285 :M
-.099(double low;)A
90 297 :M
-.181(double high;)A
108 315 :M
f7_12 sf
.358 .036(This operation activates statistics collection for the queue pointed to by )J
f11_12 sf
.096(qptr)A
f7_12 sf
.203 .02(.  It does)J
-1 -1 91 318 1 1 90 300 @b
108 327 :M
1.799 .18(this by creating a statistics record \(see Chapter 4\) that is updated automatically)J
-1 -1 91 330 1 1 90 317 @b
108 339 :M
.56 .056(whenever the queue's status is changed.  Statistics can be collected on the following)J
-1 -1 91 342 1 1 90 329 @b
108 351 :M
.042 .004(three parameters: queue length, time in the queue, and server utilization \(for resources)J
-1 -1 91 354 1 1 90 341 @b
108 363 :M
-.041(only\).  The argument )A
f11_12 sf
-.042(type)A
f7_12 sf
-.04( specifies which of the three to activate and must have one of)A
-1 -1 91 366 1 1 90 353 @b
108 375 :M
.472 .047(the following three values: LENGTH, TIME, or UTIL.  The length of a queue is the)J
-1 -1 91 378 1 1 90 365 @b
108 387 :M
.087 .009(number of activities in it, including those being served if the queue is a resource.  The)J
-1 -1 91 390 1 1 90 377 @b
108 399 :M
.593 .059(time in the queue statistic is a measure of how long an activity spends in the queue,)J
-1 -1 91 402 1 1 90 389 @b
108 411 :M
1.035 .104(including time in the server for resource queues.  Utilization statistics can only be)J
-1 -1 91 414 1 1 90 401 @b
108 423 :M
.675 .068(collected on resources.  They measure how many of the servers are busy over time.)J
-1 -1 91 426 1 1 90 413 @b
108 435 :M
.288 .029(Statistics records of type LENGTH and UTIL are interval statistics records, and ones)J
-1 -1 91 438 1 1 90 425 @b
108 447 :M
.917 .092(of type TIME are point statistics records.  The last five arguments characterize the)J
-1 -1 91 450 1 1 90 437 @b
108 459 :M
-.005(statistics record and are the same as for all statistics records.  These arguments and the)A
-1 -1 91 462 1 1 90 449 @b
108 471 :M
.074 .007(difference between point and interval statistics records are explained in the chapter on)J
-1 -1 91 474 1 1 90 461 @b
108 483 :M
-.035(statistics records.)A
-1 -1 91 486 1 1 90 473 @b
90 507 :M
f11_12 sf
-.091(void QueueResetStats\(qptr\))A
90 519 :M
-.046(RESOURCE *qptr;)A
108 537 :M
f7_12 sf
-.072(This operation resets all of the statistics records associated with the queue pointed to by)A
-1 -1 91 540 1 1 90 522 @b
108 549 :M
f11_12 sf
-.081(qptr)A
f7_12 sf
-.078( that have been previously activated.  This reset operation should be used instead of)A
-1 -1 91 552 1 1 90 539 @b
108 561 :M
-.092(StatrecReset\(\), or the initial sample point for the statistics records will missed.)A
-1 -1 91 564 1 1 90 551 @b
90 585 :M
f11_12 sf
-.019(STATREC *QueueStatPtr\(qptr, type\))A
90 597 :M
-.046(RESOURCE *qptr;)A
90 609 :M
-.206(int type;)A
108 627 :M
f7_12 sf
-.009(This operation returns a pointer to a statistics record associated with the queue pointed)A
-1 -1 91 630 1 1 90 612 @b
108 639 :M
.029 .003(to by )J
f11_12 sf
.014(qptr)A
f7_12 sf
.049 .005(.  Chapter 4 describes the various operations \(e.g., printing a report\) that can)J
-1 -1 91 642 1 1 90 629 @b
108 651 :M
.203 .02(be performed on a statistics record once you have a pointer to it.  )J
f11_12 sf
.079(Type)A
f7_12 sf
.217 .022( must be either)J
-1 -1 91 654 1 1 90 641 @b
108 663 :M
1.046 .105(LENGTH, TIME, or UTIL \(for resources only\) to select one of the three statistics)J
-1 -1 91 666 1 1 90 653 @b
108 675 :M
-.068(records associated with the queue.)A
-1 -1 91 678 1 1 90 665 @b
endp
%%Page: 36 36
%%BeginPageSetup
initializepage
(; page: 36 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(33)A
91 86 :M
f9_18 sf
2.605 .261(4.  STATISTICS RECORDS & RANDOM NUMBERS)J
90 129 :M
f7_12 sf
-.112(Statistics records are the simulation objects used to collect and process data produced by a)A
90 141 :M
-.089(simulation.  They operate on sequences of weighted numbers called )A
f11_12 sf
-.099(samples)A
f7_12 sf
-.08(.  Several statistics)A
90 153 :M
-.065(plus histograms can be computed on these sequences.)A
90 177 :M
-.085(Implementation of the Unix random number generators vary from system to system, so that a)A
90 189 :M
-.112(simulation driven by a random number generator can give different results on different)A
90 201 :M
-.085(systems.   To avoid this, YACSIM provides a random number generator that generates the)A
90 213 :M
-.058(same sequences, given the same seed, for all systems on which YACSIM has been ported.)A
90 237 :M
f9_12 sf
2.582 .258(4.1.  POINT AND INTERVAL STATISTICS RECORDS)J
90 261 :M
f7_12 sf
-.136(There are two types of statistics records: )A
f11_12 sf
-.135(point statistics records)A
f7_12 sf
-.139( and )A
f11_12 sf
-.134(interval statistics records)A
f7_12 sf
(.)S
90 273 :M
-.105(They have the same set of operations and features.  The only difference between them is in the)A
90 285 :M
-.036(way they define weights.  Samples for a point statistics record are ordered pairs )A
f11_12 sf
-.033(\(x,y\))A
f7_12 sf
-.039( where )A
f11_12 sf
(x)S
90 297 :M
f7_12 sf
-.047(is a value and )A
f11_12 sf
-.054(y)A
f7_12 sf
-.046( is the weight.  Samples for interval statistics records are ordered pairs )A
f11_12 sf
-.055(\(x,y\))A
90 309 :M
f7_12 sf
-.067(where )A
f11_12 sf
-.066(x)A
f7_12 sf
-.056( is the value and )A
f11_12 sf
-.066(y)A
f7_12 sf
-.06( is used to define the weight in the following way.  The weight for)A
90 321 :M
-.014(value )A
f11_12 sf
(x)S
f11_10 sf
0 2 rm
(i)S
0 -2 rm
f7_12 sf
-.013( is defined as )A
f11_12 sf
(w)S
f11_10 sf
0 2 rm
(i)S
0 -2 rm
f11_12 sf
-.014( = \(y)A
f11_10 sf
0 2 rm
(i+1)S
0 -2 rm
f11_12 sf
( - y)S
f11_10 sf
0 2 rm
(i)S
0 -2 rm
f11_12 sf
(\))S
f7_12 sf
-.015( where )A
f11_12 sf
(\(x)S
f11_10 sf
0 2 rm
(i)S
0 -2 rm
f11_12 sf
(,y)S
f11_10 sf
0 2 rm
(i)S
0 -2 rm
f11_12 sf
(\))S
f7_12 sf
-.014( denotes the )A
f11_12 sf
(i-th)S
f7_12 sf
-.014( sample in the sequence.  In)A
90 333 :M
-.093(the remaining discussion of statistics records, we will not make a distinction between point and)A
90 345 :M
-.055(interval statistics records.  We will describe their action on pairs of the form )A
f11_12 sf
-.059(\(v,w\))A
f7_12 sf
-.061( where )A
f11_12 sf
-.064(v)A
f7_12 sf
-.058( is a)A
90 357 :M
-.055(value and )A
f11_12 sf
-.089(w)A
f7_12 sf
-.049( is a weight.  For point statistics records, )A
f11_12 sf
-.089(w)A
f7_12 sf
-.055( is the second element of the sample)A
90 369 :M
-.063(pair.  For interval statistics records, the weight )A
f11_12 sf
-.115(w)A
f7_12 sf
-.069( of a sample is obtained from intervals as)A
90 381 :M
-.042(described above.)A
90 405 :M
.607 .061(For a sequence of weighted values )J
f11_12 sf
.158(\(v)A
f11_9 sf
0 2 rm
.152(0)A
0 -2 rm
f11_12 sf
.186(,w)A
f11_9 sf
0 2 rm
.152(0)A
0 -2 rm
f11_12 sf
.436 .044(\), \(v)J
f11_9 sf
0 2 rm
.152(1)A
0 -2 rm
f11_12 sf
.186(,w)A
f11_9 sf
0 2 rm
.152(1)A
0 -2 rm
f11_12 sf
.308 .031(\), ... , \(v)J
f11_9 sf
0 2 rm
.135(n-1)A
0 -2 rm
f11_12 sf
.186(,w)A
f11_9 sf
0 2 rm
.135(n-1)A
0 -2 rm
f11_12 sf
.135(\))A
f7_12 sf
.673 .067(, statistics records can)J
90 417 :M
-.165(calculate the following statistics:)A
126 441 :M
f9_12 sf
.723(Samples)A
198 441 :M
f7_12 sf
-.046(The number of samples.)A
234 465 :M
f9_12 sf
.453(Samples)A
f7_12 sf
.607 .061( = n)J
126 489 :M
f9_12 sf
.337(Max)A
198 489 :M
f7_12 sf
-.107(The maximum unweighted value in the sequence of samples.)A
234 513 :M
f9_12 sf
.069(Max)A
f7_12 sf
.109 .011( = max{ v)J
f7_9 sf
0 2 rm
(i)S
0 -2 rm
f7_12 sf
.067 .007( | 0 )J
cF f8_12 sf
.007(\243)A
sf
.067 .007( i <n })J
126 537 :M
f9_12 sf
.334(Min)A
198 537 :M
f7_12 sf
-.107(The minimum unweighted value in the sequence of samples.)A
234 561 :M
f9_12 sf
.064(Min)A
f7_12 sf
.107 .011( = min{ v)J
f7_9 sf
0 2 rm
(i)S
0 -2 rm
f7_12 sf
.069 .007( | 0 )J
cF f8_12 sf
.007(\243)A
sf
.069 .007( i <n })J
126 585 :M
f9_12 sf
.383(Interval)A
198 585 :M
f7_12 sf
-.103(The sampling interval.  See the description of operations EndInterval\(\))A
198 597 :M
-.09(and Interval\(\) below for a definition of this interval.)A
126 621 :M
f9_12 sf
.339(Rate)A
198 621 :M
f7_12 sf
-.117(The average sampling rate.)A
234 645 :M
f9_12 sf
.383(Rate)A
f7_12 sf
.355 .035( = )J
f9_12 sf
.39(Samples)A
f7_12 sf
.213(/)A
f9_12 sf
.378(Interval)A
126 669 :M
.226(Mean)A
198 669 :M
f7_12 sf
-.096(The weighted mean.)A
endp
%%Page: 37 37
%%BeginPageSetup
initializepage
(; page: 37 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.825 .383(Statistics Records)J
524 59 :M
2.658(34)A
88 63 -1 1 542 62 1 88 62 @a
287 73 92 48 rC
379 121 :M
psb
currentpoint
pse
287 73 :M
psb
30 dict begin
currentpoint 3 -1 roll sub neg 3 1 roll sub 2944 div 1536 3 -1 roll exch div scale currentpoint translate 64 51 translate
-8 1069 moveto
/fs 0 def
/sf {exch dup /fs exch def dup neg matrix scale makefont setfont} def
/f1 {findfont dup /cf exch def sf} def
/ns {cf sf} def
384 /Times-Bold f1
(Mean) show
1024 1069 moveto
384 /Symbol f1
(=) show
1821 554 moveto
384 /Times-Italic f1
(v) show
1984 650 moveto
224 ns
(i) show
2164 554 moveto
384 /Symbol f1
(\264) show
2459 554 moveto
384 /Times-Italic f1
(w) show
2709 650 moveto
224 ns
(i) show
1395 927 moveto
(i) show
1483 927 moveto
224 /Symbol f1
(=) show
1630 927 moveto
224 /Times-Roman f1
(0) show
1393 152 moveto
224 /Times-Italic f1
(n) show
1528 152 moveto
224 /Symbol f1
(-) show
1655 152 moveto
224 /Times-Roman f1
(1) show
1366 641 moveto
576 /Symbol f1
(\345) show
1403 1362 moveto
384 /Times-Bold f1
(Samples) show
/thick 0 def
/th { dup setlinewidth /thick exch def } def
16 th 1342 970 moveto 1489 0 rlineto stroke
end
pse
gR
gS 31 31 552 730 rC
126 142 :M
f9_12 sf
.735(StdDev)A
198 142 :M
f7_12 sf
-.095(The weighted standard deviation.)A
269 158 127 69 rC
396 227 :M
psb
currentpoint
pse
269 158 :M
psb
30 dict begin
currentpoint 3 -1 roll sub neg 3 1 roll sub 4064 div 2208 3 -1 roll exch div scale currentpoint translate 64 35 translate
-16 1149 moveto
/fs 0 def
/sf {exch dup /fs exch def dup neg matrix scale makefont setfont} def
/f1 {findfont dup /cf exch def sf} def
/ns {cf sf} def
384 /Times-Bold f1
(StdDev) show
1267 1149 moveto
384 /Symbol f1
(=) show
2322 634 moveto
384 /Times-Italic f1
(w) show
2572 730 moveto
224 ns
(i) show
2676 634 moveto
384 /Times-Roman f1
(\() show
2815 634 moveto
384 /Times-Italic f1
(v) show
2978 730 moveto
224 ns
(i) show
3152 634 moveto
384 /Symbol f1
(-) show
3436 634 moveto
384 /Times-Italic f1
(v) show
/thick 0 def
/th { dup setlinewidth /thick exch def } def
16 th 3445 317 moveto 153 0 rlineto stroke
3619 634 moveto
384 /Times-Roman f1
(\)) show
3754 463 moveto
224 /Times-Roman f1
(2) show
1900 1007 moveto
224 /Times-Italic f1
(i) show
1980 1007 moveto
224 /Symbol f1
(=) show
2119 1007 moveto
224 /Times-Roman f1
(0) show
1898 232 moveto
224 /Times-Italic f1
(n) show
2025 232 moveto
224 /Symbol f1
(-) show
2144 232 moveto
224 /Times-Roman f1
(1) show
1863 721 moveto
576 /Symbol f1
(\345) show
2694 1696 moveto
384 /Times-Italic f1
(w) show
2944 1792 moveto
224 ns
(i) show
2272 2069 moveto
(i) show
2352 2069 moveto
224 /Symbol f1
(=) show
2491 2069 moveto
224 /Times-Roman f1
(0) show
2270 1294 moveto
224 /Times-Italic f1
(n) show
2397 1294 moveto
224 /Symbol f1
(-) show
2516 1294 moveto
224 /Times-Roman f1
(1) show
2235 1783 moveto
576 /Symbol f1
(\345) show
2044 1445 moveto
384 ns
(\346) show
2044 1992 moveto
(\350) show
2044 1773 moveto
(\347) show
3046 1445 moveto
(\366) show
3046 1992 moveto
(\370) show
3046 1773 moveto
(\367) show
3302 1696 moveto
(-) show
3553 1696 moveto
384 /Times-Roman f1
(1) show
1839 1050 moveto 2085 0 rlineto stroke
/sqr {
3 index div /thick exch def
gsave
translate
dup dup neg scale
dup 4 -1 roll exch div 3 1 roll div
0 setlinewidth
newpath
0 0 moveto
dup .395 mul 0 exch lineto
.375 .214 rlineto
dup thick add dup .375 exch lineto
2 index exch lineto
dup thick 2 div sub dup 3 index exch lineto
.6 exch lineto
.375 0 lineto
clip
thick setlinewidth
newpath
dup .395 mul 0 exch moveto
.15 .085 rlineto
.375 0 lineto
thick 2 div sub dup .6 exch lineto
lineto
stroke
grestore
} def
2379 2136 384 1577 2136 16 sqr
end
pse
gR
gS 31 31 552 730 rC
90 248 :M
f7_12 sf
-.11(A statistics record can also accumulate a histogram of its input sequence.  The user specifies a)A
90 260 :M
-.07(number of bins )A
f11_12 sf
-.083(n)A
f7_12 sf
-.068( and low and high values.  The histogram will have )A
f11_12 sf
-.083(n)A
f7_12 sf
-.067( bins of equal size)A
90 272 :M
-.076(between the low and high values.  It will have two additional bins, one for all values less than)A
90 284 :M
-.107(the low value and the other for all values greater than or equal to the high value.  For each)A
90 296 :M
.055 .005(sample )J
f11_12 sf
.012(\(v,w\))A
f7_12 sf
.038 .004(, the bin that corresponds to )J
f11_12 sf
(v)S
f7_12 sf
.039 .004( is incremented by )J
f11_12 sf
(w)S
f7_12 sf
(.)S
90 320 :M
f5_12 sf
.634(Operations:)A
90 344 :M
f11_12 sf
.47 .047(STATREC *NewStatrec\(sname, type, meanflg, histflg, nbins, lowbin, highbin\))J
90 356 :M
-.206(int type;)A
90 368 :M
-.331(char *sname;)A
90 380 :M
-.211(int meanflg;)A
90 392 :M
-.151(int histflg;)A
90 404 :M
-.185(int nbins;)A
90 416 :M
-.102(double lowbin;)A
90 428 :M
-.166(double highbin;)A
108 446 :M
f7_12 sf
.455 .045(This operation creates a statistics record with name )J
f11_12 sf
.149(sname)A
f7_12 sf
.095 .01(.  )J
f11_12 sf
.142(Type)A
f7_12 sf
.389 .039( is either POINT or)J
-1 -1 91 449 1 1 90 431 @b
108 458 :M
1.331 .133(INTERVAL to specify whether the statistics record will be a point or an interval)J
-1 -1 91 461 1 1 90 448 @b
108 470 :M
2.571 .257(statistics record.  It will always compute the statistics )J
f9_12 sf
.897(Samples)A
f7_12 sf
.736 .074(, )J
f9_12 sf
1.144(Max)A
f7_12 sf
.736 .074(, )J
f9_12 sf
1.046(Min)A
f7_12 sf
(,)S
-1 -1 91 473 1 1 90 460 @b
108 482 :M
f9_12 sf
.474(Interval)A
f7_12 sf
.929 .093(, and )J
f9_12 sf
.55(Rate)A
f7_12 sf
.359 .036(.  )J
f11_12 sf
.524(Meanflg)A
f7_12 sf
1.659 .166( indicates whether or not this statistics record will)J
-1 -1 91 485 1 1 90 472 @b
108 494 :M
.568 .057(compute the mean and standard deviation.  There are two possible values.  MEANS)J
-1 -1 91 497 1 1 90 484 @b
108 506 :M
2.25 .225(indicates that the mean and standard deviation are computed, and NOMEANS)J
-1 -1 91 509 1 1 90 496 @b
108 518 :M
1.216 .122(suppresses their computation.  )J
f11_12 sf
.272(Histflg)A
f7_12 sf
1.083 .108( indicates whether or not histograms will be)J
-1 -1 91 521 1 1 90 508 @b
108 530 :M
.901 .09(computed.  Its two possible values are NOHIST and HIST.  NOHIST turns off the)J
-1 -1 91 533 1 1 90 520 @b
108 542 :M
-.105(collection of histogram data.  HIST activates the collection of a full histogram with )A
f11_12 sf
-.16(nbin)A
-1 -1 91 545 1 1 90 532 @b
108 554 :M
f7_12 sf
-.021(bins between )A
f11_12 sf
-.023(lowbin)A
f7_12 sf
-.02( and )A
f11_12 sf
-.022(highbin)A
f7_12 sf
-.021(, plus two overflow bins as described above.)A
-1 -1 91 557 1 1 90 544 @b
90 578 :M
f11_12 sf
.208 .021(void StatrecSetHistSz\(sz\))J
90 590 :M
-.166(int sz;)A
108 608 :M
f7_12 sf
.07 .007(When a new statistics record is created with histogram collection activated, a block of)J
-1 -1 91 611 1 1 90 593 @b
108 620 :M
.092 .009(memory is allocated to accumulate the histogram data.  The size of this block must be)J
-1 -1 91 623 1 1 90 610 @b
108 632 :M
.772 .077(big enough to hold all of the bins of the histogram.  To minimize calls to malloc\(\),)J
-1 -1 91 635 1 1 90 622 @b
108 644 :M
.512 .051(YACSIM maintains a pool of histogram memory blocks and does its own allocation)J
-1 -1 91 647 1 1 90 634 @b
108 656 :M
1.867 .187(whenever possible. There is a fixed default size for these blocks which is used)J
-1 -1 91 659 1 1 90 646 @b
108 668 :M
.899 .09(whenever a histogram of that size or less is needed.  If a histogram larger than the)J
-1 -1 91 671 1 1 90 658 @b
108 680 :M
1.407 .141(default size is required, malloc\(\) is called to allocate its memory.  The operation)J
-1 -1 91 683 1 1 90 670 @b
108 692 :M
.408 .041(StatrecSetHistSz\(\) can be used to change the default histogram size to )J
f11_12 sf
.102(sz)A
f7_12 sf
.238 .024(.  It must be)J
-1 -1 91 695 1 1 90 682 @b
108 704 :M
-.035(used before the first call to NewStatrec\(\).  Otherwise, the default size is left unchanged)A
-1 -1 91 707 1 1 90 694 @b
108 716 :M
-.066(and a warning message is generated.)A
-1 -1 91 719 1 1 90 706 @b
endp
%%Page: 38 38
%%BeginPageSetup
initializepage
(; page: 38 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.825 .383(Statistics Records)J
524 59 :M
2.658(35)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.128(void StatrecReset\(srptr\))A
90 93 :M
.146 .015(STATREC srptr;)J
108 111 :M
f7_12 sf
-.021(This operation resets the statistics record pointed to by )A
f11_12 sf
-.021(srptr)A
f7_12 sf
-.021( to the state it was in when)A
-1 -1 91 114 1 1 90 96 @b
108 123 :M
.159 .016(it was created.  It also sets the start of the sampling interval to the value of simulation)J
-1 -1 91 126 1 1 90 113 @b
108 135 :M
.397 .04(time when it is executed.  This operation should not be used to reset any of the three)J
-1 -1 91 138 1 1 90 125 @b
108 147 :M
-.062(statistics records associated with queues.  Use QueueResetStats\(\) instead.)A
-1 -1 91 150 1 1 90 137 @b
90 171 :M
f11_12 sf
-.031(void StatrecUpdate\(srptr, x, y\))A
90 183 :M
.14 .014(STATREC *srptr;)J
90 195 :M
-.122(double x;)A
90 207 :M
-.122(double y;)A
108 225 :M
f7_12 sf
.33 .033(This is the operation used to add another sample to the statistics record pointed to by)J
-1 -1 91 228 1 1 90 210 @b
108 237 :M
f11_12 sf
.185(srptr)A
f7_12 sf
.155 .016(.  )J
f11_12 sf
.291(X)A
f7_12 sf
.551 .055( is the value of the sample.  If the record is a point statistics record, )J
f11_12 sf
.212(y)A
f7_12 sf
.438 .044( is the)J
-1 -1 91 240 1 1 90 227 @b
108 249 :M
-.026(weight of the sample.  If it is an interval statistics record, )A
f11_12 sf
(y)S
f7_12 sf
-.028( is used to define an interval)A
-1 -1 91 252 1 1 90 239 @b
108 261 :M
-.078(weight as explained above.)A
-1 -1 91 264 1 1 90 251 @b
90 285 :M
f11_12 sf
-.151(void StatrecReport\(srptr\))A
90 297 :M
.14 .014(STATREC *srptr;)J
108 315 :M
f7_12 sf
-.036(This operation prints all of the statistics computed by the statistics record pointed to by)A
-1 -1 91 318 1 1 90 300 @b
108 327 :M
f11_12 sf
-.013(srptr)A
f7_12 sf
-.013( in a standard format.  It also prints a graphical representation of the histogram on)A
-1 -1 91 330 1 1 90 317 @b
108 339 :M
-.022(the user's display, if one was computed by the statistics record.)A
-1 -1 91 342 1 1 90 329 @b
90 363 :M
f11_12 sf
-.158(int StatrecBins\(srptr\))A
90 375 :M
.14 .014(STATREC *srptr;)J
90 399 :M
-.089(double StatrecLowBin\(srptr\))A
90 411 :M
.14 .014(STATREC *srptr;)J
90 435 :M
-.134(double StatrecHighBin\(srptr\))A
90 447 :M
.14 .014(STATREC *srptr;)J
90 471 :M
-.11(double StatrecBinSize\(srptr\))A
90 483 :M
.14 .014(STATREC *srptr;)J
90 507 :M
-.122(double StatrecHist\(srptr, i\))A
90 519 :M
.14 .014(STATREC *srptr;)J
90 531 :M
-.399(int i;)A
108 549 :M
f7_12 sf
.739 .074(These five functions access the histogram data of the statistics record pointed to by)J
-1 -1 91 552 1 1 90 534 @b
108 561 :M
f11_12 sf
.133(srptr)A
f7_12 sf
.516 .052(.  StatrecBins\(\) returns the number of bins, not counting the two overflow bins.)J
-1 -1 91 564 1 1 90 551 @b
108 573 :M
.205 .02(StatrecLowBin\(\) returns the low limit of the bin immediately above the low overflow)J
-1 -1 91 576 1 1 90 563 @b
108 585 :M
-.018(bin.  StatrecHighBin\(\) returns the low limit of the high overflow bin.  StatrecBinSize\(\))A
-1 -1 91 588 1 1 90 575 @b
108 597 :M
1.891 .189(returns the bin size.  StatrecHist\(srptr,i\) returns the value of the i-th bin of the)J
-1 -1 91 600 1 1 90 587 @b
108 609 :M
-.09(histogram pointed to by )A
f11_12 sf
-.086(srptr)A
f7_12 sf
(.)S
-1 -1 91 612 1 1 90 599 @b
endp
%%Page: 39 39
%%BeginPageSetup
initializepage
(; page: 39 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.825 .383(Statistics Records)J
524 59 :M
2.658(36)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.165(int StatrecSamples\(srptr\))A
90 93 :M
.14 .014(STATREC *srptr;)J
90 117 :M
-.191(double StatrecMinVal\(srptr\))A
90 129 :M
.14 .014(STATREC *srptr;)J
90 153 :M
-.19(double StatrecMaxVal\(srptr\))A
90 165 :M
.14 .014(STATREC *srptr;)J
90 189 :M
-.22(double StatrecMean\(srptr\))A
90 201 :M
.14 .014(STATREC *srptr;)J
90 225 :M
-.1(double StatrecSdv\(srptr\))A
90 237 :M
.14 .014(STATREC *srptr;)J
108 255 :M
f7_12 sf
4.344 .434(These five operations return statistics computed by the statistics record.)J
-1 -1 91 258 1 1 90 240 @b
108 267 :M
-.02(StatrecSamples\(\) returns the statistic )A
f9_12 sf
-.026(Samples)A
f7_12 sf
-.022(.   StatrecMinVal\(\) and StatrecMaxVal\(\))A
-1 -1 91 270 1 1 90 257 @b
108 279 :M
1.051 .105(return the statistics )J
f9_12 sf
.415(Min)A
f7_12 sf
.545 .054( and )J
f9_12 sf
.384(Max.)A
f7_12 sf
1.039 .104(  StatrecMean\(\) returns )J
f9_12 sf
.428(Mean)A
f7_12 sf
1.351 .135( and StatrecSdv\(\))J
-1 -1 91 282 1 1 90 269 @b
108 291 :M
1.148 .115(returns )J
f9_12 sf
.354(StdDev)A
f7_12 sf
(.)S
-1 -1 91 294 1 1 90 281 @b
90 315 :M
f11_12 sf
-.182(void StatrecEndInterval\(srptr\))A
90 327 :M
.14 .014(STATREC *srptr;)J
90 351 :M
-.212(double StatrecInterval\(srptr\))A
90 363 :M
.14 .014(STATREC *srptr;)J
90 387 :M
-.207(double StatrecRate\(srptr\))A
90 399 :M
.14 .014(STATREC *srptr;)J
108 417 :M
f7_12 sf
.094 .009(Creating a new statistics record sets the beginning time of the sampling interval to the)J
-1 -1 91 420 1 1 90 402 @b
108 429 :M
-.072(value of simulation time when it is created.  If you want to start the sampling interval at)A
-1 -1 91 432 1 1 90 419 @b
108 441 :M
-.063(a later time, you can use the operation StatrecReset\(\) described previously.  The ending)A
-1 -1 91 444 1 1 90 431 @b
108 453 :M
-.024(time of the sampling interval is initially the same as the starting time and is reset to the)A
-1 -1 91 456 1 1 90 443 @b
108 465 :M
.111 .011(current simulation time each time a new sample is entered.  This defines the sampling)J
-1 -1 91 468 1 1 90 455 @b
108 477 :M
-.005(interval to be the period from the time the statistics record is created, or the last time it)A
-1 -1 91 480 1 1 90 467 @b
108 489 :M
.421 .042(was reset, to the time of the last sample.  The operation StatrecEndInterval\(\) sets the)J
-1 -1 91 492 1 1 90 479 @b
108 501 :M
.454 .045(ending time of the interval to the value of simulation time when it is executed.  This)J
-1 -1 91 504 1 1 90 491 @b
108 513 :M
-.025(enables the user to end the sampling interval at someplace other than a sampling point.)A
-1 -1 91 516 1 1 90 503 @b
108 525 :M
.95 .095(StatrecInterval\(\) returns the statistic )J
f9_12 sf
.224(Interval)A
f7_12 sf
.878 .088( and StatrecRate\(\) returns the statistic)J
-1 -1 91 528 1 1 90 515 @b
108 537 :M
f9_12 sf
.448(Rate)A
f7_12 sf
(.)S
-1 -1 91 540 1 1 90 527 @b
90 561 :M
f5_12 sf
.762(Examples)A
126 585 :M
f11_10 sf
.468 .047(srptr1 = NewStatrec\("Stat1", POINT, NOMEANS, NOHIST, 0, 0.0, 0.0\);)J
162 602 :M
f7_10 sf
1.574 .157(This creates a point statistics record named "Stat1" that will only compute the)J
162 613 :M
1.468 .147(statistics Samples, Max, Min, Interval, and Rate.  The last three arguments are)J
162 624 :M
-.149(ignored.)A
126 647 :M
f11_10 sf
.685 .069(srptr2 = NewStatrec\("Stat2", INTERVAL, MEANS, NOHIST, 0, 0.0, 0.0\);)J
162 664 :M
f7_10 sf
.812 .081(This creates an interval statistics record named "Stat2."  It will compute all seven)J
162 675 :M
.148 .015(statistics, but no histogram.  The last three arguments are ignored.)J
endp
%%Page: 40 40
%%BeginPageSetup
initializepage
(; page: 40 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.825 .383(Statistics Records)J
524 59 :M
2.658(37)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f11_10 sf
.462 .046(srptr3 = NewStatrec\("Stat3", POINT, MEANS, HIST, 5, 1.0, 11.0\);)J
162 98 :M
f7_10 sf
1.578 .158(The point statistics record created here will compute all seven statistics plus a)J
162 109 :M
.021 .002(histogram with five equally spaced bins between 1.0 and 11.0 and two overflow bins.)J
162 120 :M
.356 .036(The bin size will be 2.0.)J
126 143 :M
f11_10 sf
-.103(StatrecUpdate\(srptr1, 3.5, 1.0\);)A
162 160 :M
f7_10 sf
.339 .034(Since )J
f11_10 sf
.09(srptr1)A
f7_10 sf
.308 .031( points to a point statistics record, this statement will add a sample with)J
162 171 :M
.186 .019(value 3.5 and weight 1.0.)J
126 194 :M
f11_10 sf
-.092(StatrecUpdate\(srptr3, 4.0, 25.6\))A
162 211 :M
f7_10 sf
.065 .007(This adds a sample with value 4 and weight 25.6 to the point statistics record pointed)J
162 222 :M
.049 .005(to by )J
f11_10 sf
.023(srptr3)A
f7_10 sf
(.)S
126 245 :M
f11_10 sf
-.103(StatrecUpdate\(srptr2, 2.0, 1.0\);)A
126 256 :M
-.103(StatrecUpdate\(srptr2, 3.0, 3.0\);)A
126 267 :M
-.103(StatrecUpdate\(srptr2, 3.0, 4.5\);)A
126 278 :M
-.103(StatrecUpdate\(srptr2, 1.5, 5.0\);)A
162 301 :M
f7_10 sf
.293 .029(This sequence of updates on the statistics record pointed to by )J
f11_10 sf
.083(srptr2)A
f7_10 sf
.218 .022( will result in a)J
162 312 :M
1.356 .136(sample with value 2.0 and weight 3.0 - 1.0 = 2.0, a sample with value 3.0 and)J
162 323 :M
.195 .019(weight 1.5, and a sample with value 3.0 and weight 0.5.)J
126 346 :M
f11_10 sf
-.138(StatrecReset\(srptr3\); )A
270 346 :M
-.045(\(executed at time t1\))A
126 357 :M
-.25(StatrecEndInterval\(srptr3\);)A
270 357 :M
-.045(\(executed at time t2\))A
162 374 :M
f7_10 sf
.173 .017(These two operations will define the sampling interval to be from t1 to t2.)J
90 397 :M
f5_12 sf
.792(Comments:)A
90 421 :M
f7_12 sf
-.108(If you invoke one of the operations that returns a statistic or histogram value and that statistic or)A
90 433 :M
-.099(histogram is not computed by the statistics record, then the simulator will print a warning)A
90 445 :M
-.083(message.  If histograms are computed, but the values are all zero, StatrecReport\(\) will print a)A
90 457 :M
-.082(warning message instead of the histogram graph.  If a negative weight is computed for an)A
90 469 :M
-.145(interval statistic due to a later value having an earlier time, StatrecReport\(\) will compute and)A
90 481 :M
-.117(print the statistics and the histogram, but will print the warning message )A
f11_12 sf
-.116(Invalid statistics;)A
90 493 :M
-.249(interval error)A
f7_12 sf
(.)S
90 517 :M
f9_12 sf
2.806 .281(4.2.  RANDOM NUMBER GENERATION)J
90 541 :M
f7_12 sf
-.123(There is an internal YACSIM random number generator is called YacRand.  It uses a)A
90 553 :M
-.101(multiplicative congruential random number generator suggested by Shedler in Lavenberg's)A
90 565 :M
-.089("Computer Performance Modeling Handbook."  It is the same generator used in the IBM)A
90 577 :M
-.105(System/360 \(save for the difference in 360 and IEEE 754 floating point arithmetic\).  The)A
90 589 :M
-.108(generator is specified as)A
126 613 :M
.115(X)A
f7_10 sf
0 2 rm
.069(n+1)A
0 -2 rm
f7_12 sf
.142 .014( = aX)J
f7_10 sf
0 2 rm
.066(n)A
0 -2 rm
f7_12 sf
.203 .02( mod m,)J
90 639 :M
-.006(where a = 16807 \( = 7)A
f7_10 sf
0 -3 rm
(5)S
0 3 rm
f7_12 sf
-.006(\) and m = 2147483647 \( = 2)A
f7_10 sf
0 -3 rm
(31)S
0 3 rm
f7_12 sf
( - 1\))S
90 663 :M
-.107(A call to YacRand actually produces a uniformly distributed random number x, such that 0 )A
cF f8_12 sf
-.107(\243)A
sf
-.107( x)A
90 675 :M
-.044(< 1, by dividing the \(integer\) X)A
f7_10 sf
0 2 rm
-.042(n+1 )A
0 -2 rm
f7_12 sf
-.047(by the modulus m and returning this value.)A
endp
%%Page: 41 41
%%BeginPageSetup
initializepage
(; page: 41 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.825 .383(Statistics Records)J
524 59 :M
2.658(38)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f5_12 sf
.634(Operations:)A
90 105 :M
f11_12 sf
-.065(double YacRand\(\))A
108 123 :M
f7_12 sf
.134 .013(This operation is used to access the YACSIM random number generator.  It generates)J
-1 -1 91 126 1 1 90 108 @b
108 135 :M
-.085(and returns the next random number in the sequence.)A
-1 -1 91 138 1 1 90 125 @b
90 159 :M
f11_12 sf
.142 .014(void YacSeed\(seed\))J
90 171 :M
-.179(double seed;)A
108 189 :M
f7_12 sf
.796 .08(This operation seeds the random number generator, which otherwise uses a seed of)J
-1 -1 91 192 1 1 90 174 @b
108 201 :M
.453 .045(0.5.  In order to maintain a correspondence between YacRand and drand48, the seed)J
-1 -1 91 204 1 1 90 191 @b
108 213 :M
.897 .09(value, which is a double, should be greater than 0 and less than 1.  It is multiplied)J
-1 -1 91 216 1 1 90 203 @b
108 225 :M
-.043(inside YacSeed by the modulus to produce an integer seed between 1 and the modulus.)A
-1 -1 91 228 1 1 90 215 @b
108 237 :M
-.081(Calling YacSeed\(\) with a seed of 0 causes it to use the default value of 0.5.)A
endp
%%Page: 42 42
%%BeginPageSetup
initializepage
(; page: 42 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(39)A
178 86 :M
f9_18 sf
2.423 .242(5.  THE SIMULATION DRIVER)J
90 129 :M
f9_12 sf
2.519 .252(5.1.  THE DRIVER)J
90 153 :M
f7_12 sf
-.104(The driver is that part of a simulator that controls the sequencing of activities.  It usually does)A
90 165 :M
-.106(this by means of a linked list called an )A
f11_12 sf
-.1(event list)A
f7_12 sf
-.112(.  When a user schedules an activity to take)A
90 177 :M
-.113(place in the future, the driver inserts that activity into the event list. The driver also keeps the)A
90 189 :M
-.123(list ordered by inserting new activities in such a way that all activities scheduled to occur before)A
90 201 :M
-.142(the new activity are ahead of it, and all activities scheduled to occur after the new activity are)A
90 213 :M
-.076(behind it in the list.  In other words, the event list is kept ordered by the scheduled times of its)A
90 225 :M
-.134(activities.  The driver initiates activities in the order they appear in the list by always taking the)A
90 237 :M
-.152(activity at the head of the list to initiate next.  Each time the driver removes an activity that has a)A
90 249 :M
-.155(scheduled time greater than the current simulation time, it increases simulation time to the time)A
90 261 :M
-.123(of that activity.)A
90 285 :M
f5_12 sf
.634(Operations:)A
90 309 :M
f11_12 sf
-.095(void DriverReset\(\))A
108 327 :M
f7_12 sf
.219 .022(This operation resets simulation time to 0.0, clears the event list, clears all simulation)J
-1 -1 91 330 1 1 90 312 @b
108 339 :M
-.069(queues, and destroys all existing simulation objects.  That is, it takes the simulator back)A
-1 -1 91 342 1 1 90 329 @b
108 351 :M
.773 .077(to the state it was in when it first started execution and before any objects \(queues,)J
-1 -1 91 354 1 1 90 341 @b
108 363 :M
1.117 .112(activities, and statistics records\) were created.  You must recreate all objects after)J
-1 -1 91 366 1 1 90 353 @b
108 375 :M
-.107(executing DriverReset\(\) before you can run another simulation.)A
-1 -1 91 378 1 1 90 365 @b
90 399 :M
f11_12 sf
-.156(int DriverRun\(timeinc\))A
90 411 :M
-.212(double timeinc;)A
108 429 :M
f7_12 sf
-.013(This operation starts or restarts a simulation.  Once the user invokes this operation, the)A
-1 -1 91 432 1 1 90 414 @b
108 441 :M
.14 .014(simulator will run for )J
f11_12 sf
.042(timeinc)A
f7_12 sf
.124 .012( units of simulation time, until its event list is empty,  or)J
-1 -1 91 444 1 1 90 431 @b
108 453 :M
.985 .099(until it is interrupted, and then return control to the user.  The user can continue a)J
-1 -1 91 456 1 1 90 443 @b
108 465 :M
-.023(simulation by invoking DriverRun\(\) again with a new time increment )A
f11_12 sf
(t)S
f7_12 sf
-.023(.  The simulator)A
-1 -1 91 468 1 1 90 455 @b
108 477 :M
.116 .012(will pick up where it left off and run for )J
f11_12 sf
.045 .004(t )J
f7_12 sf
.175 .017(more units of time.  Invoking DriverReset\(\))J
-1 -1 91 480 1 1 90 467 @b
108 489 :M
-.017(before another run will start the simulation over at time 0.0.  If DriverRun\(\) is invoked)A
-1 -1 91 492 1 1 90 479 @b
108 501 :M
-.065(with )A
f11_12 sf
-.067(timeinc)A
f7_12 sf
-.06( less than or equal to 0.0, the simulator will run until the event list is empty)A
-1 -1 91 504 1 1 90 491 @b
108 513 :M
.612 .061(or the simulation is interrupted.  The return value is 0 if the simulation runs the full)J
-1 -1 91 516 1 1 90 503 @b
108 525 :M
f11_12 sf
.064(timeinc)A
f7_12 sf
.213 .021( units of time or exhausts its event list.  Due to the operation DriverInterrupt\(\))J
-1 -1 91 528 1 1 90 515 @b
108 537 :M
.075 .008(described below, it is possible for the simulation to terminate before that time.  In that)J
-1 -1 91 540 1 1 90 527 @b
108 549 :M
.527 .053(case, DriverRun\(\) will return a non-zero value as explained for the DriverInterrupt\(\))J
-1 -1 91 552 1 1 90 539 @b
108 561 :M
-.035(operation.)A
-1 -1 91 564 1 1 90 551 @b
90 585 :M
f11_12 sf
-.22(void DriverInterrupt\(retval\))A
90 597 :M
-.365(int retval;)A
108 615 :M
f7_12 sf
2.204 .22(This operation suspends a simulation run before the requested simulation time)J
-1 -1 91 618 1 1 90 600 @b
108 627 :M
-.006(increment is completed.  The user can invoke it from within an event or a process, and)A
-1 -1 91 630 1 1 90 617 @b
108 639 :M
.345 .035(it will cause the interruption to occur when that activity terminates or suspends.  The)J
-1 -1 91 642 1 1 90 629 @b
108 651 :M
.598 .06(argument )J
f11_12 sf
.11(retval)A
f7_12 sf
.354 .035( is the value returned by DriverRun\(\).  A )J
f11_12 sf
.11(retval)A
f7_12 sf
.336 .034( of 0 will generate an)J
-1 -1 91 654 1 1 90 641 @b
108 663 :M
-.013(error termination of the simulation as that value is reserved to signify a simulation that)A
-1 -1 91 666 1 1 90 653 @b
108 675 :M
-.062(has run to completion.)A
-1 -1 91 678 1 1 90 665 @b
endp
%%Page: 43 43
%%BeginPageSetup
initializepage
(; page: 43 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
4 .4(The Simulation Driver)J
524 59 :M
2.658(40)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
(double GetSimTime\(\))S
108 99 :M
f7_12 sf
-.087(This operation returns the current simulation time.  You can invoke it from anywhere in)A
-1 -1 91 102 1 1 90 84 @b
108 111 :M
-.104(the simulation code.)A
-1 -1 91 114 1 1 90 101 @b
90 135 :M
f5_12 sf
.668(Examples:)A
126 159 :M
f11_10 sf
-.083(DriverRun\(10.0\);)A
162 176 :M
f7_10 sf
.194 .019(This statement transfers control to the driver for 10.0 units of simulation time.)J
126 199 :M
f11_10 sf
-.089(DriverRun\(0.0\);)A
162 216 :M
f7_10 sf
1.098 .11(This statement also transfers control to the driver, but it will not return until the)J
162 227 :M
-.011(event queue is empty or an interrupt occurs.)A
126 250 :M
f11_10 sf
-.089(i = DriverRun\(100.0\);)A
162 267 :M
f7_10 sf
.528 .053(This statement transfers control to the driver for 100 units of simulation time.  The)J
162 278 :M
.308 .031(return value i will be 0 if the simulation runs for the full 100 time steps or the event)J
162 289 :M
.06 .006(list is exhausted, and will be non-zero if it is interrupted.)J
126 312 :M
f11_10 sf
-.089(DriverRun\(5.5\);)A
126 323 :M
-.089(DriverRun\(5.0\);)A
126 334 :M
-.176(DriverReset\(\);)A
126 345 :M
-.083(DriverRun\(10.5\);)A
162 362 :M
f7_10 sf
1.163 .116(The first statement will run the simulator for 5.5. units of simulation time.  The)J
162 373 :M
1.07 .107(second statement will then execute 5.0 more units of simulation time.  The third)J
162 384 :M
.565 .057(statement resets the simulator and the fourth initiates a simulation run of 10.5 time)J
162 395 :M
1.017 .102(units.  The effect of this sequence is to perform two simulations of 10.5 units of)J
162 406 :M
.298 .03(simulation time each.)J
126 429 :M
f11_10 sf
-.263(DriverInterrupt\(5\);)A
162 446 :M
f7_10 sf
.126 .013(This interrupts the simulator and returns the value 5 to the user.)J
90 469 :M
f9_12 sf
2.368 .237(5.2.  THE EVENT LIST)J
90 493 :M
f7_12 sf
-.14(Recall that the activities on the event list are ordered by their scheduled time of occurrence.)A
90 505 :M
-.107(Each time a new activity is added to the event list, it is inserted in the proper order.  If the event)A
90 517 :M
-.127(list is large, the insertion of activities can account for a significant amount of the time to)A
90 529 :M
-.101(perform a simulation.  Therefore, several techniques for reducing the insertion time of event list)A
90 541 :M
-.138(have been developed.  YACSIM uses one called a )A
f11_12 sf
-.141(calendar queue)A
f7_12 sf
(.)S
90 565 :M
-.096(Calendar queues break up the event list into bins in such a way that the proper bin for an)A
90 577 :M
-.12(activity can be quickly determined.  The details of this approach can be found in the paper)A
90 589 :M
-.143("Calendar Queues: A Fast O\(1\) Priority Queue Implementation for the Simulation Event Set)A
90 601 :M
.37 .037(Problem," )J
f11_12 sf
.365 .036(Communications of the ACM)J
f7_12 sf
.231 .023(, Vol. 31, No. 10, Oct. 1988, pp. 1220-1227.  The)J
90 613 :M
-.124(calendar queue insertion algorithm includes a method of resizing the number and size of the)A
90 625 :M
-.083(bins as the queue grows and shrinks in order to optimize its performance.  While this technique)A
90 637 :M
-.092(works well for most distributions of times if the queue is large, its performance can deteriorate)A
90 649 :M
-.095(for certain distributions and for simulations with small event lists.  Therefore a method for the)A
90 661 :M
-.098(user to control the number of bins and their size has been implemented.)A
90 685 :M
-.132(The parameters of the calendar queue bins can be specified with command line arguments to the)A
90 697 :M
-.084(simulation.  If a simulation is invoked with the argument )A
f11_12 sf
-.103(+bi)A
f7_12 sf
-.085(, where )A
f11_12 sf
-.078(i )A
cF f12_12 sf
-.078(\263)A
sf
-.078( 1)A
f7_12 sf
-.083(,  the simulator will)A
90 709 :M
-.098(use a calendar queue with exactly )A
f11_12 sf
-.068(i)A
f7_12 sf
-.099( bins.  A simulation invoked with the argument )A
f11_12 sf
-.131(+wj)A
f7_12 sf
-.097(, where )A
f11_12 sf
(j)S
endp
%%Page: 44 44
%%BeginPageSetup
initializepage
(; page: 44 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
4 .4(The Simulation Driver)J
524 59 :M
2.658(41)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f7_12 sf
-.08(is a floating point number, will use a calendar queue with all bins of size )A
f11_12 sf
-.058(j)A
f7_12 sf
-.082(.  In both these cases)A
90 93 :M
-.129(the automatic resizing of the bins will be turned off.  The argument )A
f11_12 sf
-.157(+l)A
f7_12 sf
-.122( or the special case )A
f11_12 sf
-.276(+b1)A
90 105 :M
f7_12 sf
-.099(will cause the simulator to use a simple sequential search for insertion of new activities.  This is)A
90 117 :M
-.143(a much simpler implementation than the calendar queue, and it can be faster if the event list)A
90 129 :M
-.093(never grows very large during a simulation.   The )A
f11_12 sf
-.112(+bi)A
f7_12 sf
-.058(,)A
f11_12 sf
-.125(+wj)A
f7_12 sf
-.09( and )A
f11_12 sf
-.111(+l)A
f7_12 sf
-.104( arguments must precede any)A
90 141 :M
-.085(arguments that are to be passed to UserMain\(\) as explained in Section 1.3.  The operation)A
90 153 :M
-.108(EventListSelect\(\) described below provides another way to specify the type and parameters of)A
90 165 :M
-.094(the event list.)A
90 189 :M
-.106(Unfortunately, there does not appear to be any good way to predict in advance the optimal size)A
90 201 :M
-.072(for the bins, or whether or not fixed or variable bins will perform better.  Several statistics)A
90 213 :M
-.104(described in the following section can be collected on the event list's behavior and may be)A
90 225 :M
-.102(helpful in choosing optimal bin parameters.)A
90 249 :M
-.156(The default event list implementation is the calendar queue with automatic bin sizing activated.)A
90 273 :M
f5_12 sf
.634(Operations:)A
90 297 :M
f11_12 sf
.25 .025(void EventListSelect\(type, bins, bwidth\))J
90 309 :M
-.206(int type;)A
90 321 :M
-.208(int bins;)A
90 333 :M
-.102(double bwidth;)A
108 351 :M
f7_12 sf
.634 .063(This operations provides the user with a means of selecting which type of event list)J
-1 -1 91 354 1 1 90 336 @b
108 363 :M
.535 .053(implementation will be used.  It has the same effect as the command line arguments)J
-1 -1 91 366 1 1 90 353 @b
108 375 :M
f11_12 sf
.316(+bi)A
f7_12 sf
.272 .027(, )J
f11_12 sf
.352(+wi)A
f7_12 sf
.55 .055(, and )J
f11_12 sf
.311(+l)A
f7_12 sf
.773 .077(, but it can be called from with the user's program.  )J
f11_12 sf
.317(Type)A
f7_12 sf
.774 .077( is either)J
-1 -1 91 378 1 1 90 365 @b
108 387 :M
.855 .086(CALQUE to specify the calendar queue implementation or LINQUE to specify the)J
-1 -1 91 390 1 1 90 377 @b
108 399 :M
.265 .026(linear linked list implementation.  If the type is CALQUE, then )J
f11_12 sf
.075(bins)A
f7_12 sf
.259 .026( specifies a fixed)J
-1 -1 91 402 1 1 90 389 @b
108 411 :M
.786 .079(number of bins and )J
f11_12 sf
.263(bwidth)A
f7_12 sf
.537 .054( a fixed bin width.  If )J
f11_12 sf
.241(bins)A
f7_12 sf
.531 .053( is less than 2 and )J
f11_12 sf
.263(bwidth)A
f7_12 sf
.724 .072( less)J
-1 -1 91 414 1 1 90 401 @b
108 423 :M
.633 .063(than or equal to 0.0, the automatic bin sizing algorithm is used.  )J
f9_12 sf
1.094 .109(CAUTION:  This)J
-1 -1 91 426 1 1 90 413 @b
108 435 :M
4.584 .458(operation must be called in UserMain\(\) at the very beginning of a)J
-1 -1 91 438 1 1 90 425 @b
108 447 :M
3.556 .356(simulation and before any other simulation operations are called.  No)J
-1 -1 91 450 1 1 90 437 @b
108 459 :M
2.327 .233(warning is generated if it is called later.)J
-1 -1 91 462 1 1 90 449 @b
90 483 :M
f11_12 sf
-.017(int EventListSize\(\))A
108 501 :M
f7_12 sf
-.114(This operation returns the number of activities currently in the event list.)A
-1 -1 91 504 1 1 90 486 @b
90 525 :M
f11_12 sf
.19 .019(void EventListCollectStats\(type, meanflg, histflg, nbin, low, high\))J
90 537 :M
-.206(int type;)A
90 549 :M
-.211(int meanflg;)A
90 561 :M
-.151(int histflg;)A
90 573 :M
-.249(int nbin;)A
90 585 :M
-.099(double low;)A
90 597 :M
-.181(double high;)A
108 615 :M
f7_12 sf
.541 .054(Calling this operation activates statistics collection for the event list.  It does this by)J
-1 -1 91 618 1 1 90 600 @b
108 627 :M
-.092(creating statistics records \(see Chapter 5\) that are updated automatically whenever there)A
-1 -1 91 630 1 1 90 617 @b
108 639 :M
-.11(is any change in the event list.  The following four different statistics can be collected as)A
-1 -1 91 642 1 1 90 629 @b
108 651 :M
-.072(specified by the argument )A
f11_12 sf
-.074(type)A
f7_12 sf
-.089( .)A
-1 -1 91 654 1 1 90 641 @b
143 669 :M
12 f13_1 :p
20 :m
-.22(type)A
271 669 :M
141 :m
-.165(Statistic Record Update Value)A
-1 -1 91 672 1 1 90 654 @b
126 687 :M
(LENGTH)S
207 687 :M
-.07(The size of the list \(i.e., the number of activities in the list\).)A
-1 -1 91 690 1 1 90 672 @b
126 705 :M
.223(BINS)A
207 705 :M
-.112(The number of bins in a calendar queue \(ignored for the linear list\))A
-1 -1 91 708 1 1 90 690 @b
endp
%%Page: 45 45
%%BeginPageSetup
initializepage
(; page: 45 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
4 .4(The Simulation Driver)J
524 59 :M
2.658(42)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f7_12 sf
-.091(BINWIDTH)A
207 81 :M
-.078(The size of a calendar queue's bins \(ignored for the linear list\))A
-1 -1 91 84 1 1 90 66 @b
126 99 :M
-.124(EMPTYBINS)A
207 99 :M
.235 .024(The number of empty calendar queue bins \(ignored for the linear)J
-1 -1 91 102 1 1 90 84 @b
108 111 :M
-.166(list\))A
-1 -1 91 114 1 1 90 101 @b
108 129 :M
.721 .072(The last five arguments characterize the statistics record and are the same as for all)J
-1 -1 91 132 1 1 90 114 @b
108 141 :M
.138 .014(statistics records \(see Chapter 5\).  All four of the statistics records associated with the)J
-1 -1 91 144 1 1 90 131 @b
108 153 :M
-.054(event list are point statistics records that are updated with a weight of 1.0 every time an)A
-1 -1 91 156 1 1 90 143 @b
108 165 :M
-.123(activity is added to or deleted from the event list.)A
-1 -1 91 168 1 1 90 155 @b
90 189 :M
f11_12 sf
-.011(void EventListResetStats\(\))A
108 207 :M
f7_12 sf
-.02(This operation resets all of the statistics records associated with the event list that have)A
-1 -1 91 210 1 1 90 192 @b
108 219 :M
3.431 .343(been previously activated.  This reset operation should be used instead of)J
-1 -1 91 222 1 1 90 209 @b
108 231 :M
-.068(StatrecReset\(\).)A
-1 -1 91 234 1 1 90 221 @b
90 255 :M
f11_12 sf
.092 .009(STATREC *EventListStatPtr\(type\))J
90 267 :M
-.206(int type;)A
108 285 :M
f7_12 sf
-.072(This operation returns a pointer to one of the statistics records associated with the event)A
-1 -1 91 288 1 1 90 270 @b
108 297 :M
.661 .066(list.  Chapter 4 describes the various operations, such as printing a summary report,)J
-1 -1 91 300 1 1 90 287 @b
108 309 :M
.209 .021(that can be performed on a statistics records through its pointer.  )J
f11_12 sf
.073(Type)A
f7_12 sf
.173 .017( must be one of)J
-1 -1 91 312 1 1 90 299 @b
108 321 :M
.996 .1(LENGTH, BINS, BINWIDTH, or EMPTYBINS to select one of the four statistics)J
-1 -1 91 324 1 1 90 311 @b
108 333 :M
-.075(record types.  If the selected type has not been activated, a NULL pointer is returned.)A
-1 -1 91 336 1 1 90 323 @b
90 357 :M
f5_12 sf
.668(Examples:)A
126 381 :M
f11_10 sf
.544 .054(EventListSelect\(LINQUE, 0, 0.0\);)J
162 398 :M
f7_10 sf
.907 .091(This statement selects the linear linked list implementation of the event list.  The)J
162 409 :M
-.026(last two arguments are ignored.)A
126 432 :M
f11_10 sf
.783 .078(EventListSelect\(CALQUE, 0, 0.0\);)J
162 449 :M
f7_10 sf
1.427 .143(This statement selects the calendar queue implementation of the event list with)J
162 460 :M
.352 .035(automatic bin sizing.)J
126 483 :M
f11_10 sf
.768 .077(EventListSelect\(CALQUE, 4, 2.05\);)J
162 500 :M
f7_10 sf
.378 .038(This statement selects the calendar queue implementation of the event list with four)J
162 511 :M
.368 .037(bins of width 2.5.)J
126 534 :M
f11_10 sf
.994 .099(EventListCollectStats\(BINWIDTH, MEANS, HIST, 10, 0.0, 10.0\);)J
162 551 :M
f7_10 sf
.757 .076(This statement activates the collection of statistics on the bin widths and specifies)J
162 562 :M
.024 .002(that both means and histograms will be collected.)J
endp
%%Page: 46 46
%%BeginPageSetup
initializepage
(; page: 46 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(43)A
242 86 :M
f9_18 sf
3.282 .328(6.  DEBUGGING)J
90 129 :M
f7_12 sf
-.101(In addition to the standard C debugging tools, the YACSIM simulator provides a tracing)A
90 141 :M
-.103(capability and numerous error and warning messages.  Although we have attempted to make)A
90 153 :M
-.101(the error and warning messages self-explanatory, it is difficult to provide much detail in a)A
90 165 :M
-.082(single line of text.  Therefore, the next two sections list all of these messages and provide)A
90 177 :M
-.092(additional information on their causes.  The difference between warning and error messages is)A
90 189 :M
-.122(that conditions that generate error messages will also terminated the simulation, while)A
90 201 :M
-.106(conditions that generate warning messages will not.  The third section explains the tracing)A
90 213 :M
-.129(capability built into the simulators.)A
90 237 :M
f9_12 sf
3.53 .353(6.1.  WARNING MESSAGES)J
90 261 :M
f11_12 sf
-.216(All histogram entries = 0:)A
108 283 :M
f7_12 sf
-.013(The statistics record operation StatrecReport\(\) generates this warning when it attempts)A
108 295 :M
.393 .039(to print a histogram graph and finds all of the bin entries zero.  It prints this warning)J
108 307 :M
-.048(instead of the graph.)A
90 331 :M
f11_12 sf
-.137(Can only set the default histogram size before calling NewStatrec:)A
108 353 :M
f7_12 sf
.406 .041(The operation StatrecSetHistSz\(\) was called after one or more statistics records have)J
108 365 :M
-.065(been created.  In this case, the default size for histograms is not changed.)A
90 389 :M
f11_12 sf
-.113(Can only set the default stack size before calling NewProcess:)A
108 411 :M
f7_12 sf
.875 .087(The operation ProcessSetStkSz\(\) was called after one or more processes have been)J
108 423 :M
-.052(created.  In this case, the default size for process stacks is not changed.)A
90 447 :M
f11_12 sf
-.176(Invalid event list statistics type; statistics not collected:)A
108 469 :M
f7_12 sf
-.044(EventListCollectStat\(\) has been called with an invalid )A
f11_12 sf
-.046(type)A
f7_12 sf
-.045( argument.  It must be either)A
108 481 :M
-.029(LENGTH, BINS, BINWIDTH, or EMPTYBINS.  Statistics collection is not activated.)A
90 505 :M
f11_12 sf
-.283(Invalid statistics; interval error:)A
108 527 :M
f7_12 sf
-.064(The operation StatrecReport\(\) of an interval statistics record generates this warning if it)A
108 539 :M
-.123(encounters a negative interval due to two samples where the later one has an earlier time)A
108 551 :M
.212 .021(value than the first one.  Since this is usually an error, a warning is generated, but the)J
108 563 :M
-.088(report is still printed in case it is not.)A
90 587 :M
f11_12 sf
-.121(Invalid statistic type for queues, can't collect:)A
108 609 :M
f7_12 sf
.583 .058(QueueCollectStat\(\) has been called with an invalid )J
f11_12 sf
.143(type)A
f7_12 sf
.44 .044( argument.  It must be either)J
108 621 :M
-.063(LENGTH, TIME, or UTIL.  Statistics collection is not activated.)A
90 645 :M
f11_12 sf
-.155(Invalid statistic type for queue:)A
108 667 :M
f7_12 sf
1.628 .163(QueueStatPtr\(\) has been called with an invalid )J
f11_12 sf
.421(type)A
f7_12 sf
1.298 .13( argument.  It must be either)J
108 679 :M
.477 .048(LENGTH, TIME, or UTIL.  The operation returns the null pointer instead of a valid)J
108 691 :M
-.078(statistics record pointer.)A
endp
%%Page: 47 47
%%BeginPageSetup
initializepage
(; page: 47 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(44)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.131(Not all message bytes received:)A
108 103 :M
f7_12 sf
-.037(The operation ProcessReceiveMsg\(\) does not receive all of the characters in a message)A
108 115 :M
.166 .017(if the )J
f11_12 sf
.079(bytes)A
f7_12 sf
.267 .027(  argument is less than the message size.  The remaining characters can be)J
108 127 :M
-.105(obtained with additional calls to ProcessReceiveMsg\(\).)A
90 151 :M
f11_12 sf
-.087(Preemptive Resume resources will only use one server:)A
108 173 :M
f7_12 sf
-.075(The operation that creates resources generates this warning when a value different from)A
108 185 :M
1.892 .189(1 is entered for the number of servers and the queuing discipline is one of the)J
108 197 :M
.322 .032(preemptive resume disciplines.  The resource will be created with only one server no)J
108 209 :M
-.089(matter how many are requested.)A
90 233 :M
f11_12 sf
-.226(Process statistics collection already set:)A
108 255 :M
f7_12 sf
.685 .068(This message is generated when the operation ProcessCollectStat\(\) is applied to the)J
108 267 :M
-.059(same process more than once.)A
90 291 :M
f11_12 sf
-.149(Processor sharing resources will only use one serer:)A
108 313 :M
f7_12 sf
-.075(The operation that creates resources generates this warning when a value different from)A
108 325 :M
.169 .017(1 is entered for the number of servers and the queuing discipline is processor sharing.)J
108 337 :M
-.095(The resource will be created with only one server no matter how many are requested.)A
90 361 :M
f11_12 sf
-.23(Queue length statistics collection already set:)A
108 383 :M
f7_12 sf
.97 .097(This message is generated when the operation ResourceCollectStat\(\) activating the)J
108 395 :M
-.115(collection of queue length statisics is applied to the same resource more than once.)A
90 419 :M
f11_12 sf
-.233(Queue time statistics collection already set:)A
108 441 :M
f7_12 sf
.97 .097(This message is generated when the operation ResourceCollectStat\(\) activating the)J
108 453 :M
-.121(collection of queue time statisics is applied to the same resource more than once.)A
90 477 :M
f11_12 sf
-.241(Queue utilization statistics collection already set:)A
108 499 :M
f7_12 sf
.97 .097(This message is generated when the operation ResourceCollectStat\(\) activating the)J
108 511 :M
-.129(collection of queue utilization statistics is applied to the same resource more than once.)A
90 535 :M
f11_12 sf
-.184(Setting a set flag:)A
108 557 :M
f7_12 sf
.19 .019(The flag operation FlagSet\(\) generates this warning when it is applied to a flag that is)J
108 569 :M
1.514 .151(already set.  A warning is given because two or more successive applications of)J
108 581 :M
-.055(FlagSet\(\) are redundant.)A
90 605 :M
f11_12 sf
-.187(Setting a set semaphore:)A
108 627 :M
f7_12 sf
-.093(The semaphore operation SemaphoreSet\(\) generates this warning when it is applied to a)A
108 639 :M
.841 .084(semaphore that is already set.  A warning is given because two or more successive)J
108 651 :M
-.088(applications of SemaphoreSet\(\) are redundant.)A
90 675 :M
f11_12 sf
-.106(Setting an IVAR that is not linked to a condition :)A
108 697 :M
f7_12 sf
-.047(This usually means that a condition has been created before one of the state variables it)A
108 709 :M
-.059(depends on has been created.)A
endp
%%Page: 48 48
%%BeginPageSetup
initializepage
(; page: 48 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(45)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.115(Setting an FVAR that is not linked to a condition:)A
108 103 :M
f7_12 sf
-.047(This usually means that a condition has been created before one of the state variables it)A
108 115 :M
-.059(depends on has been created.)A
90 139 :M
f11_12 sf
-.243(Statistics not collected; cannot print report:)A
108 161 :M
f7_12 sf
-.01(The operation ActivityStatRept\(\) was called for some activity in order to print a report)A
108 173 :M
1.373 .137(of that activity's statistics, but the collection of statistics had not been previously)J
108 185 :M
-.145(activated.)A
90 209 :M
f11_12 sf
-.098(Time slice only used with round robin queue discipline:)A
108 231 :M
f7_12 sf
.815 .082(The operation that creates a new resource generates this warning when a time slice)J
108 243 :M
-.094(value other than the default value is entered for any resource other than Round Robin or)A
108 255 :M
-.081(Round Robin Preemptive Resume With Priorities.)A
90 279 :M
f11_12 sf
-.119(Trying to receive a negative number of bytes:)A
108 301 :M
f7_12 sf
.23 .023(The operation ProcessReceiveMsg\(\) was called with a negative "bytes" argument.  In)J
108 313 :M
-.028(this case the operation will not receive any of the messages bytes, but they are retained)A
108 325 :M
-.08(by the system and can be read by a subsequent call to ProcessReceiveMsg\(\).)A
90 349 :M
f11_12 sf
-.115(YacRand seed out of range; default seed used)A
108 371 :M
f7_12 sf
1.295 .129(The argument to YacSeed\(\) must be > 0.0 and < 1.0.  Otherwise the argument is)J
108 383 :M
-.077(ignored and the default seed value is used.)A
90 407 :M
f9_12 sf
2.924 .292(6.2.  ERROR MESSAGES)J
90 431 :M
f11_12 sf
-.148(ActivityGetParPtr\(\) must be called from within an activity:)A
108 453 :M
f7_12 sf
.649 .065(Since only activities can have a parent, ActivityGetParPtr\(\) can only be called from)J
108 465 :M
.035 .003(within an activity's body.)J
90 489 :M
f11_12 sf
-.16(Can not call DriverReset\(\) from within a process or an event:)A
108 511 :M
f7_12 sf
1.612 .161(The driver can only be reset after returning from DriverRun\(\), that is, while the)J
108 523 :M
-.11(simulation is not active.)A
90 547 :M
f11_12 sf
-.201(Can not delay for a negative time:)A
108 569 :M
f7_12 sf
-.077(The operation ProcessDelay\(\) generates this error message if it is called with a negative)A
108 581 :M
-.164(time increment.)A
90 605 :M
f11_12 sf
-.181(Can not request negative service time from a resource:)A
108 627 :M
f7_12 sf
-.09(An attempt to schedule \(or reschedule\) an activity for a negative amount of service time)A
108 639 :M
-.067(from a resource generates this message.)A
90 663 :M
f11_12 sf
-.208(Can not reschedule a deleting event:)A
108 685 :M
f7_12 sf
.02 .002(Since a deleting event will always be destroyed after it occurs, it makes no sense for it)J
108 697 :M
-.081(to reschedule itself.)A
endp
%%Page: 49 49
%%BeginPageSetup
initializepage
(; page: 49 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(46)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.185(Can not reschedule a pending event:)A
108 103 :M
f7_12 sf
.115 .011(A pending event is one that has been scheduled, but has not yet occurred.  An attempt)J
108 115 :M
-.061(to schedule such an event is an error.)A
90 139 :M
f11_12 sf
-.189(Can not schedule an activity to occur in the past:)A
108 161 :M
f7_12 sf
-.098(This error results from an attempt to schedule an activity to happen at a time prior to the)A
108 173 :M
-.129(current simulation time.)A
90 197 :M
f11_12 sf
-.193(Changing Delete Flag of a scheduled event:)A
108 219 :M
f7_12 sf
1.013 .101(Once an event has been scheduled, you can not change its delete flag until after it)J
108 231 :M
.115(occurs.)A
90 255 :M
f11_12 sf
-.13(EventGetState\(\) must be called from within an active event:)A
108 277 :M
f7_12 sf
.654 .065(The state of an event can only be accessed by the user from within the body of that)J
108 289 :M
(event.)S
90 313 :M
f11_12 sf
-.045(EventReschedule\(\) can only be invoked from within an event body:)A
108 335 :M
f7_12 sf
-.091(EventReschedule\(\) is provided only for an event to reschedule itself.)A
90 359 :M
f11_12 sf
-.152(Events can not be scheduled in the past:)A
108 381 :M
f7_12 sf
-.143(An attempt to schedule an event with a negative time increment generates this message.)A
90 405 :M
f11_12 sf
-.155(EventSetDelFlag\(\) not called from within an event:)A
108 427 :M
f7_12 sf
-.109(The delete flag of an event can only be set from within the body of that event.)A
90 451 :M
f11_12 sf
-.085(EventSetState\(\) has NULL pointer, but not called from an event:)A
108 473 :M
f7_12 sf
-.024(This operation must be called from within an event's body or the argurment must point)A
108 485 :M
-.059(to an event.)A
90 509 :M
f11_12 sf
.567 .057(Fset only works with FVAR's:)J
108 531 :M
f7_12 sf
1.275 .127(Trying to apply the operation Fset\(\) to an integer state variable will generate this)J
108 543 :M
.05(message.)A
90 567 :M
f11_12 sf
-.204(Histograms not calculated for this statistics record:)A
108 589 :M
f7_12 sf
.755 .075(This error results when there is an attempt to access the histogram information in a)J
108 601 :M
-.085(statistics record that does not compute histograms.)A
90 625 :M
f11_12 sf
-.036(Invalid statistics record type, use POINT or INTERVAL:)A
108 647 :M
f7_12 sf
2.826 .283(The type argument to the NewStatrec\(\) operations must be either POINT or)J
108 659 :M
-.122(INTERVAL.)A
90 683 :M
f11_12 sf
-.007(Invalid histogram flag, use HIST or NOHIST:)A
108 705 :M
f7_12 sf
-.076(The histflg argument to the NewStatrec\(\) operations must be either HIST or NOHIST.)A
endp
%%Page: 50 50
%%BeginPageSetup
initializepage
(; page: 50 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(47)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.14(Invalid statistics type passed to EventListStatPtr\(\):)A
108 103 :M
f7_12 sf
.074 .007(The type passed must be LENGTH, BINS, BINWIDTH, or EMPTYBINS.)J
90 127 :M
f11_12 sf
.667 .067(Iset only works with IVAR's:)J
108 149 :M
f7_12 sf
.182 .018(Trying to apply the operation Iset\(\) to a floating point state variable will generate this)J
108 161 :M
.05(message.)A
90 185 :M
f11_12 sf
-.049(Malloc fails in ... :)A
108 207 :M
f7_12 sf
.073 .007(This error message indicates that the dynamic memory allocation function has run out)J
108 219 :M
(of memory.)S
90 243 :M
f11_12 sf
-.226(Means not calculated for this statistics record:)A
108 265 :M
f7_12 sf
.578 .058(The statistics record operation StatrecMean\(\) generates this error if it is applied to a)J
108 277 :M
-.091(statistics record that was created with argument )A
f11_12 sf
-.106(meanflg)A
f7_12 sf
-.144( = NOMEANS.)A
90 301 :M
f11_12 sf
-.053(Null Activity Referenced:)A
108 323 :M
f7_12 sf
-.117(A null pointer has been passed to an operation that expects a pointer to an activity.)A
90 347 :M
f11_12 sf
-.056(Null queue element pointer passed to ... :)A
108 369 :M
f7_12 sf
-.111(A null pointer to a queue element has been passed to an operation.)A
90 393 :M
f11_12 sf
-.029(Null queue pointer passed to ... :)A
108 415 :M
f7_12 sf
-.092(A null pointer to a queue has been passed to an operation.)A
90 439 :M
f11_12 sf
-.094(Only processes can perform forking or blocking schedules:)A
108 461 :M
f7_12 sf
.008 .001(An attempt to execute one of the activity forking operations from any place except the)J
108 473 :M
-.033(body of a process generates this error.)A
90 497 :M
f11_12 sf
-.096(Only processes can send blocking messages:)A
108 519 :M
f7_12 sf
.493 .049(ProcessSendMsg\(\) can only be called from within the body of a process it the )J
f11_12 sf
.156(blkflg)A
108 531 :M
f7_12 sf
-.058(argument is BLOCK.)A
90 555 :M
f11_12 sf
-.246(Only processes can wait at barriers:)A
108 577 :M
f7_12 sf
-.119(The operation BarrierSync\(\) has been called from some place other than from within the)A
108 589 :M
.149 .015(body of a process.)J
90 613 :M
f11_12 sf
-.136(Processes can only be scheduled once:)A
108 635 :M
f7_12 sf
.352 .035(You can not schedule a process once it has been scheduled.  You can create multiple)J
108 647 :M
.27 .027(processes with the same body and even the same name, but each of them can only be)J
108 659 :M
-.045(scheduled once.)A
90 683 :M
f11_12 sf
-.056(ProcessCheckMsg\(\) can not be invoked from within a process body:)A
108 705 :M
f7_12 sf
-.075(An attempt to execute the operation ProcessCheckMsg\(\) from someplace other than the)A
108 717 :M
-.033(body of a process generates this error.)A
endp
%%Page: 51 51
%%BeginPageSetup
initializepage
(; page: 51 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(48)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f11_12 sf
-.08(ProcessDelay\(\) can only be invoked from within a process body:)A
108 103 :M
f7_12 sf
-.107(An attempt to execute the operation ProcessDelay\(\) from any place except the body of a)A
108 115 :M
-.033(process generates this error.)A
90 139 :M
f11_12 sf
-.065(ProcessJoin\(\) can only be invoked from within a process body:)A
108 161 :M
f7_12 sf
-.006(An attempt to execute the operation ProcessJoin\(\) from any place except the body of a)A
108 173 :M
-.033(process generates this error.)A
90 197 :M
f11_12 sf
-.048(ProcessReceiveMsg\(\) can only be invoked from within a process body:)A
108 219 :M
f7_12 sf
.801 .08(Calling the operation ProcessReceiveMsg\(\) from anyplace but within the body of a)J
108 231 :M
-.064(process will generate this error message.)A
90 255 :M
f11_12 sf
-.123(ProcessReceiveMsg\(\) has a null receive buffer:)A
108 277 :M
f7_12 sf
-.045(The operation ProcessReceiveMsg\(\) was called with its "buf" argument NULL, but the)A
108 289 :M
-.03(message was not empty.)A
90 313 :M
f11_12 sf
-.095(ProcessSendMsg\(\) must be called from within an activity:)A
108 335 :M
f7_12 sf
-.057(Only processes and events can call ProcessSendMsg\(\).)A
90 359 :M
f11_12 sf
-.053(ProcessSleep\(\) can only be invoked from within a process body:)A
108 381 :M
f7_12 sf
-.084(An attempt to execute the operation ProcessSleep\(\) from any place except the body of a)A
108 393 :M
-.033(process generates this error.)A
90 417 :M
f11_12 sf
-.047(ResourceUse\(\) must be called from a processess' body:)A
108 439 :M
f7_12 sf
-.051(Only Processes can call ResourceUse\(\).)A
90 463 :M
f11_12 sf
-.212(Returning unallocated object to pool:)A
108 485 :M
f7_12 sf
.253 .025(There has been an attempt to return something to a pool that was not obtained from a)J
108 497 :M
.167(pool.)A
90 521 :M
f11_12 sf
-.153(Simulator interrupted with 0 stopflag:)A
108 543 :M
f7_12 sf
-.022(This error occurs when the user invokes DriverInterrupt\(i\) with )A
f11_12 sf
(i)S
f7_12 sf
-.02( = 0.  Since )A
f11_12 sf
(i)S
f7_12 sf
-.03( becomes)A
108 555 :M
-.048(the return value for DriverRun\(\) and a return value of 0 indicates a normal termination,)A
108 567 :M
-.071(not an interrupt, the argument )A
f11_12 sf
-.05(i)A
f7_12 sf
-.079( must be non-zero.)A
90 591 :M
f11_12 sf
-.143(Std. Dev. not calculated for this statistics record:)A
108 613 :M
f7_12 sf
.981 .098(The statistics record operation StatrecSdv\(\) generates this error if it is applied to a)J
108 625 :M
-.094(statistics record that was created with the argument )A
f11_12 sf
-.111(meanflg)A
f7_12 sf
-.151( = NOMEANS.)A
90 649 :M
f11_12 sf
-.134(Unimplemented queuing discipline:)A
108 671 :M
f7_12 sf
1.367 .137(The first argument to NewResource\(\) specifies the type of queuing discipline the)J
108 683 :M
.02 .002(resource will use.  If that does not match with one of the implemented disciplines, this)J
108 695 :M
-.052(error is generated.)A
endp
%%Page: 52 52
%%BeginPageSetup
initializepage
(; page: 52 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
.919(Debugging)A
524 59 :M
2.658(49)A
88 63 -1 1 542 62 1 88 62 @a
90 81 :M
f9_12 sf
3.544 .354(6.3.  TRACING)J
90 105 :M
f7_12 sf
-.117(YACSIM has extensive tracing capability.  The user can turn it on and off from any place)A
90 117 :M
-.116(within a simulation and can set it to one of six levels to generate different amounts of trace data.)A
90 129 :M
(The global variable )S
f9_12 sf
(TraceLevel)S
f7_12 sf
.005 .001( controls the trace output.  Setting )J
f9_12 sf
(TraceLevel)S
f7_12 sf
( to 0 turns all)S
90 141 :M
-.059(tracing off.  Setting it to 1, 2, 3, 4, or 5 sets the tracing level to that value.  Tracing level )A
f11_12 sf
(i)S
90 153 :M
f7_12 sf
-.098(contains all the information of level )A
f11_12 sf
-.071(j)A
f7_12 sf
-.082(, for )A
f11_12 sf
-.085(j < i.)A
f7_12 sf
-.107(  Level 1 tracing only prints warning messages)A
90 165 :M
-.123(and the final simulation time at the end of the simulation.  Level 2 gives a coarse trace of when)A
90 177 :M
-.083(the simulation program calls and returns from the driver and when it switches processes.  Level)A
90 189 :M
-.13(3 tracing gives much more information about the invocation of all simulation operations)A
90 201 :M
-.121(available to the user.  Level 4 adds information about the status of each queue every time it)A
90 213 :M
-.101(changes.  Level 5 tracing give very low level traces including event list operations.)A
90 237 :M
-.077(In addition to altering the variable )A
f9_12 sf
-.099(TraceLevel)A
f7_12 sf
-.079(, the user can set the trace level at the beginning)A
90 249 :M
-.087(of a simulation with a command line argument of the form )A
f11_12 sf
-.078(+ti,)A
f7_12 sf
-.088( where )A
f11_12 sf
-.079(0 )A
cF f12_12 sf
-.079(\243)A
sf
-.079( i )A
cF f12_12 sf
-.079(\243)A
sf
-.079( 5)A
f7_12 sf
-.08(.  This sets the)A
90 261 :M
-.123(trace level to )A
f11_12 sf
-.09(i.)A
f7_12 sf
-.138(  In this way the trace level can be changed without recompiling the simulation)A
90 273 :M
-.125(program.  The )A
f11_12 sf
-.121(+ti)A
f7_12 sf
-.125( argument must precede any command line arguments that are to be passed to)A
90 285 :M
-.024(UserMain\(\), as explained in Section 1.3.)A
90 309 :M
-.115(Most of the trace output should be self-explanatory.  Every time a simulation object is)A
90 321 :M
-.087(mentioned in the trace output, it is referred to by its name.  This is the name the user assigns to)A
90 333 :M
-.103(a simulation object when it is created.  This name is arbitrary and need not be unique.  Each)A
90 345 :M
-.133(object in the trace is also referenced by a unique ID number assigned it automatically when it is)A
90 357 :M
-.107(created.  The form of the reference is)A
f11_12 sf
-.124( name[ID] )A
f7_12 sf
-.123(where )A
f11_12 sf
-.149(name)A
f7_12 sf
-.106( is the object's name and )A
f11_12 sf
-.145(ID)A
f7_12 sf
-.097( is its)A
90 369 :M
-.046(unique ID number.  This form can be changed with the global variable )A
f9_12 sf
-.056(TraceIDs)A
f7_12 sf
-.035(.   If it is set)A
90 381 :M
-.102(to 0, all the ID numbers in the trace are forced to 0.  passeing the command line argument )A
f11_12 sf
-.073(-i )A
f7_12 sf
-.171(has)A
90 393 :M
-.107(the same effect.)A
endp
%%Page: 53 53
%%BeginPageSetup
initializepage
(; page: 53 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(50)A
158 86 :M
f9_18 sf
2.692 .269(APPENDIX 1:  DEFINED SYMBOLS)J
90 129 :M
f7_12 sf
-.08(This appendix list the symbols defined in the file sim.h.  They are used extensively as)A
90 141 :M
-.089(arguments to many of the YACSIM operations.  They are described in the discussions of the)A
90 153 :M
-.1(operations that use them and are only listed here.)A
126 189 :M
f9_12 sf
3.281 .328(Types of Activity Scheduling:)J
162 213 :M
f7_12 sf
-.13(INDEPENDENT)A
270 213 :M
(0)S
162 225 :M
-.166(BLOCK)A
270 225 :M
(1)S
162 237 :M
(FORK)S
270 237 :M
(2)S
126 261 :M
f9_12 sf
2.923 .292(Event Characteristics:)J
162 285 :M
f7_12 sf
-.463(DELETE)A
270 285 :M
(1)S
162 297 :M
-.377(NODELETE)A
270 297 :M
(0)S
126 321 :M
f9_12 sf
3.002 .3(Message Parameters:)J
162 345 :M
f7_12 sf
-.283(ANYTYPE )A
270 345 :M
(-1)S
162 357 :M
-.206(ANYSENDER)A
270 357 :M
(0)S
162 369 :M
-.165(NOBLOCK)A
270 369 :M
(0)S
162 381 :M
-.166(BLOCK)A
270 381 :M
(1)S
126 405 :M
f9_12 sf
3.163 .316(Statistics Record Characteristics:)J
162 429 :M
f7_12 sf
-.22(NOMEANS)A
270 429 :M
(0)S
162 441 :M
-.248(MEANS)A
270 441 :M
(1)S
162 453 :M
.114(HIST)A
270 453 :M
(2)S
162 465 :M
(NOHIST)S
270 465 :M
(3)S
162 477 :M
-.08(POINT)A
270 477 :M
(4)S
162 489 :M
-.282(INTERVAL)A
270 489 :M
(5)S
108 513 :M
f9_12 sf
2.417 .242(Argument and Buffer Size:)J
162 537 :M
f7_12 sf
.116(UNKNOWN)A
252 537 :M
(-1)S
162 549 :M
-.146(DEFAULTSTK)A
252 549 :M
(0)S
351 189 :M
f9_12 sf
3.159 .316(Types of Queue Disciplines:)J
387 213 :M
f7_12 sf
.328(FCFS)A
495 213 :M
(1)S
387 225 :M
.187(FCFSPRWP)A
495 225 :M
(2)S
387 237 :M
.13(LCFSPR)A
495 237 :M
(3)S
387 249 :M
-.049(PROCSHAR)A
495 249 :M
(4)S
387 261 :M
(RR)S
495 261 :M
(5)S
387 273 :M
-.331(RAND)A
495 273 :M
(6)S
387 285 :M
.093(LCFSPRWP)A
495 285 :M
(7)S
387 297 :M
.499(SJN)A
495 297 :M
(8)S
387 309 :M
.064(RRPRWP)A
495 309 :M
(9)S
387 321 :M
.108(LCFS)A
495 321 :M
(10)S
351 345 :M
f9_12 sf
3.346 .335(Queue Statistics:)J
387 369 :M
f7_12 sf
-.44(TIME)A
495 369 :M
(1)S
387 381 :M
-.105(UTIL)A
495 381 :M
(2)S
387 393 :M
(LENGTH)S
495 393 :M
(3)S
387 405 :M
.223(BINS)A
495 405 :M
(4)S
387 417 :M
-.091(BINWIDTH)A
495 417 :M
(5)S
387 429 :M
-.124(EMPTYBINS)A
495 429 :M
(6)S
351 453 :M
f9_12 sf
2.596 .26(Event List Types:)J
387 477 :M
f7_12 sf
-.331(CALQUE)A
495 477 :M
(0)S
387 489 :M
-.128(LINQUE)A
495 489 :M
(1)S
351 513 :M
f9_12 sf
.668(Miscellaneous)A
387 537 :M
f7_12 sf
-.997(ME)A
495 537 :M
(0)S
endp
%%Page: 54 54
%%BeginPageSetup
initializepage
(; page: 54 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(51)A
123 86 :M
f9_18 sf
2.51 .251(APPENDIX 2: SUMMARY OF OPERATIONS)J
251 125 :M
f9_12 sf
2.387 .239(ACTIVITY Operations)J
86 116 -1 2 88 114 1 86 114 @a
-1 -2 88 116 1 2 86 114 @b
88 116 -1 2 542 114 1 88 114 @a
542 116 -1 2 544 114 1 542 114 @a
-1 -2 544 116 1 2 542 114 @b
86 130 -1 2 88 128 1 86 128 @a
-1 -2 88 130 1 2 86 128 @b
88 130 -1 2 542 128 1 88 128 @a
542 130 -1 2 544 128 1 542 128 @a
-1 -2 544 130 1 2 542 128 @b
-1 -2 88 128 1 2 86 116 @b
-1 -2 544 128 1 2 542 116 @b
90 145 :M
f7_10 sf
-.087(ActivityArgSize\(aptr\))A
315 145 :M
.128 .013(/* Returns the size of an argument )J
532 145 :M
.222(*/)A
90 156 :M
-.012(ActivityCollectStats\(aptr\))A
315 156 :M
.168 .017(/* Activates statistics collection for an activity )J
532 156 :M
.222(*/)A
90 167 :M
-.103(ActivityGetArg\(aptr\))A
315 167 :M
.136 .014(/* Returns the argument pointer of an activity)J
532 167 :M
.222(*/)A
90 178 :M
-.025(ActivityGetMyPtr\(\))A
315 178 :M
.203 .02(/* Returns a pointer to the active activity )J
532 178 :M
.222(*/)A
90 189 :M
-.047(ActivityGetParPtr\(\))A
315 189 :M
.139 .014(/* Returns a pointer to the active activity's parent)J
532 189 :M
.222(*/)A
90 200 :M
-.064(ActivitySchedCond\(aptr, condptr, blkflg\))A
315 200 :M
.031 .003(/* Schedules an activity to wait for a condition)J
532 200 :M
.222(*/)A
90 211 :M
-.007(ActivitySchedFlag\(aptr, flgptr, blkflg\))A
315 211 :M
.051 .005(/* Schedules an activity to wait for a flag)J
532 211 :M
.222(*/)A
90 222 :M
.039 .004(ActivitySchedRes\(aptr, rptr, timeinc, blkflg\))J
315 222 :M
-.008(/* Schedules an activity to wait use a resource)A
532 222 :M
.222(*/)A
90 233 :M
-.019(ActivitySchedSema\(aptr, semptr, blkflg\))A
315 233 :M
-.003(/* Schedules an activity to wait for a semaphore)A
532 233 :M
.222(*/)A
90 244 :M
-.01(ActivitySchedTime\(aptr, timeinc, blkflg\))A
315 244 :M
.11 .011(/* Schedules an activity to start in the future)J
532 244 :M
.222(*/)A
90 255 :M
-.073(ActivitySetArg\(aptr,argptr,argsize\))A
315 255 :M
.179 .018(/* Sets the argument pointer of an activity)J
532 255 :M
.222(*/)A
90 266 :M
-.009(ActivityStatPtr\(aptr\))A
315 266 :M
.081 .008(/* Returns a pointer to an activity's stat record)J
532 266 :M
.222(*/)A
90 277 :M
-.02(ActivityStatRept\(aptr\))A
315 277 :M
.278 .028(/* Prints a report of an activity's statistics)J
532 277 :M
.222(*/)A
253 296 :M
f9_12 sf
3.09 .309(PROCESS Operations)J
86 287 -1 2 88 285 1 86 285 @a
-1 -2 88 287 1 2 86 285 @b
88 287 -1 2 542 285 1 88 285 @a
542 287 -1 2 544 285 1 542 285 @a
-1 -2 544 287 1 2 542 285 @b
86 301 -1 2 88 299 1 86 299 @a
-1 -2 88 301 1 2 86 299 @b
88 301 -1 2 542 299 1 88 299 @a
542 301 -1 2 544 299 1 542 299 @a
-1 -2 544 301 1 2 542 299 @b
-1 -2 88 299 1 2 86 287 @b
-1 -2 544 299 1 2 542 287 @b
90 316 :M
f7_10 sf
-.072(NewProcess\(pname, bodyname, stksz\))A
315 316 :M
.135 .013(/* Creates & return a pointer to a new sim. process)J
532 316 :M
.222(*/)A
90 327 :M
-.101(ProcessCheckMsg\(type, sender\))A
315 327 :M
-.039(/* Checks for a message of a given type and sender)A
532 327 :M
.222(*/)A
90 338 :M
-.103(ProcessDelay\(timeinc\))A
315 338 :M
-.031(/* Suspends the current process for a time period)A
532 338 :M
.222(*/)A
90 349 :M
-.072(ProcessJoin\(\))A
315 349 :M
-.008(/* Suspend until all forked child activities terminate)A
532 349 :M
.222(*/)A
90 360 :M
-.016(ProcessReceiveMsg\(buf, bytes, blkflg, type, sender\))A
315 360 :M
-.032(/* Copies received data into buf and returns its size)A
532 360 :M
.222(*/)A
90 371 :M
.045 .005(ProcessSendMsg\(dest, buf, bytes, blkflg, type\))J
315 371 :M
-.006(/* Sends a message to a process)A
532 371 :M
.222(*/)A
90 382 :M
-.014(ProcessSetPriority\(procptr, p\))A
315 382 :M
.174 .017(/* Sets the priority of a process)J
532 382 :M
.222(*/)A
90 393 :M
-.014(ProcessSetStkSz\(stksz\))A
315 393 :M
-.004(/* Set the default stack size)A
532 393 :M
.222(*/)A
90 404 :M
-.109(ProcessSleep\(\))A
315 404 :M
-.014(/* Suspends the current process for an indefinite time )A
532 404 :M
.222(*/)A
261 434 :M
f9_12 sf
2.536 .254(EVENT Operations)J
86 425 -1 2 88 423 1 86 423 @a
-1 -2 88 425 1 2 86 423 @b
88 425 -1 2 542 423 1 88 423 @a
542 425 -1 2 544 423 1 542 423 @a
-1 -2 544 425 1 2 542 423 @b
86 439 -1 2 88 437 1 86 437 @a
-1 -2 88 439 1 2 86 437 @b
88 439 -1 2 542 437 1 88 437 @a
542 439 -1 2 544 437 1 542 437 @a
-1 -2 544 439 1 2 542 437 @b
-1 -2 88 437 1 2 86 425 @b
-1 -2 544 437 1 2 542 425 @b
90 454 :M
f7_10 sf
-.092(NewEvent\(ename, bodyname, delflg, etype\))A
315 454 :M
-.016(/* Creates and returns a pointer to a new event)A
532 454 :M
.222(*/)A
90 465 :M
-.109(EventGetDelFlag\(eptr\))A
315 465 :M
(/* Returns DELETE \(1\) or NODELETE \(0\) )S
532 465 :M
.222(*/)A
90 476 :M
-.101(EventGetState\(\))A
315 476 :M
.162 .016(/* Returns the state of an event )J
532 476 :M
.222(*/)A
90 487 :M
-.112(EventGetType\(eptr\) )A
315 487 :M
.175 .018(/* Returns the events type)J
532 487 :M
.222(*/)A
90 498 :M
-.127(EventReschedCond\(condptr, stval\))A
315 498 :M
-.015(/* Reschedules an event to wait for a condition)A
532 498 :M
.222(*/)A
90 509 :M
-.058(EventReschedFlag\(flgptr, stval\))A
315 509 :M
-.012(/* Reschedules an event to wait for a flag)A
532 509 :M
.222(*/)A
90 520 :M
-.025(EventReschedRes\(resptr, timeinc, stval\) )A
315 520 :M
-.031(/* Reschedules an event to use a resource )A
532 520 :M
.222(*/)A
90 531 :M
-.072(EventReschedSema\(semptr, stval\))A
315 531 :M
-.027(/* Reschedules an event to wait for a semaphore)A
532 531 :M
.222(*/)A
90 542 :M
-.059(EventReschedTime\(timeinc, stval\))A
315 542 :M
-.016(/* Reschedules an event to occur in the future)A
532 542 :M
.222(*/)A
90 553 :M
-.06(EventSetDelFlag\(\))A
315 553 :M
-.03(/* Makes an event deleting)A
532 553 :M
.222(*/)A
90 564 :M
-.033(EventSetState\(stvat\))A
315 564 :M
.073 .007(/* Sets state used to designate a return point )J
532 564 :M
.222(*/)A
90 575 :M
-.063(EventSetType\(eptr, etype\))A
315 575 :M
.282 .028(/* Sets the event's type)J
532 575 :M
.222(*/)A
260 605 :M
f9_12 sf
2.804 .28(QUEUE Operations)J
86 596 -1 2 88 594 1 86 594 @a
-1 -2 88 596 1 2 86 594 @b
88 596 -1 2 542 594 1 88 594 @a
542 596 -1 2 544 594 1 542 594 @a
-1 -2 544 596 1 2 542 594 @b
86 610 -1 2 88 608 1 86 608 @a
-1 -2 88 610 1 2 86 608 @b
88 610 -1 2 542 608 1 88 608 @a
542 610 -1 2 544 608 1 542 608 @a
-1 -2 544 610 1 2 542 608 @b
-1 -2 88 608 1 2 86 596 @b
-1 -2 544 608 1 2 542 596 @b
90 625 :M
f7_10 sf
.303 .03(QueueCollectStats\(qptr, type, meanflg, histflg, nbin, low, high\))J
315 636 :M
.017 .002(/* Initiates statistics collection for a queue)J
532 636 :M
.222(*/)A
90 647 :M
-.126(QueueResetStats\(qptr\))A
315 647 :M
.028 .003(/* Resets statistics collectin for a queue)J
532 647 :M
.222(*/)A
90 658 :M
-.033(QueueStatPtr\(qptr, type\) )A
315 658 :M
.145 .014(/* Returns a pointer to a queue's statistics)J
532 658 :M
.222(*/)A
242 677 :M
f9_12 sf
2.534 .253(SEMAPHORE Operations)J
86 668 -1 2 88 666 1 86 666 @a
-1 -2 88 668 1 2 86 666 @b
88 668 -1 2 542 666 1 88 666 @a
542 668 -1 2 544 666 1 542 666 @a
-1 -2 544 668 1 2 542 666 @b
86 682 -1 2 88 680 1 86 680 @a
-1 -2 88 682 1 2 86 680 @b
88 682 -1 2 542 680 1 88 680 @a
542 682 -1 2 544 680 1 542 680 @a
-1 -2 544 682 1 2 542 680 @b
-1 -2 88 680 1 2 86 668 @b
-1 -2 544 680 1 2 542 668 @b
90 697 :M
f7_10 sf
-.061(NewSemaphore\(sname, i\) )A
315 697 :M
.018 .002(/* Creates & returns a pointer to a new semaphore)J
532 697 :M
.222(*/)A
90 708 :M
-.17(SemaphoreDecr\(sptr\))A
315 708 :M
.015 .001(/* Decrement the sem. value & return the new value)J
532 708 :M
.222(*/)A
endp
%%Page: 55 55
%%BeginPageSetup
initializepage
(; page: 55 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.861 .386(Appendix 2)J
542 59 :M
2.658(52)A
90 81 :M
f7_10 sf
-.014(SemaphoreInit\(sptr, i\))A
315 81 :M
.269 .027(/* If queue is empty its value is set to i )J
532 81 :M
.222(*/)A
90 92 :M
-.083(SemaphoreSet\(sptr\))A
315 92 :M
.267 .027(/* Set sem. to 1 if empty, or release an activity)J
532 92 :M
.222(*/)A
90 103 :M
-.059(SemaphoreSignal\(sptr\))A
315 103 :M
.142 .014(/* Signals the semaphore)J
532 103 :M
.222(*/)A
90 114 :M
-.132(SemaphoreValue\(sptr\))A
315 114 :M
.041 .004(/* Returns the value of the semaphore)J
532 114 :M
.222(*/)A
90 125 :M
-.115(SemaphoreWait\(sptr\))A
315 125 :M
(/* Wait on a semaphore)S
532 125 :M
.222(*/)A
90 136 :M
-.061(SemaphoreWaiting\(sptr\) )A
315 136 :M
.132 .013(/* Returns the # of activities in the queue)J
532 136 :M
.222(*/)A
253 155 :M
f9_12 sf
2.722 .272(BARRIER Operations)J
86 146 -1 2 88 144 1 86 144 @a
-1 -2 88 146 1 2 86 144 @b
88 146 -1 2 542 144 1 88 144 @a
542 146 -1 2 544 144 1 542 144 @a
-1 -2 544 146 1 2 542 144 @b
86 160 -1 2 88 158 1 86 158 @a
-1 -2 88 160 1 2 86 158 @b
88 160 -1 2 542 158 1 88 158 @a
542 160 -1 2 544 158 1 542 158 @a
-1 -2 544 160 1 2 542 158 @b
-1 -2 88 158 1 2 86 146 @b
-1 -2 544 158 1 2 542 146 @b
90 175 :M
f7_10 sf
-.172(NewBarrier\(bname, i\))A
315 175 :M
-.036(/* Creates and returns a pointer to a new barrier)A
532 175 :M
.222(*/)A
90 186 :M
-.091(BarrierInit\(bptr, i\))A
315 186 :M
.18 .018(/* If a barrier's queue is empty, sets its value to i )J
532 186 :M
.222(*/)A
90 197 :M
-.367(BarrierNeeded\(bptr\))A
315 197 :M
-.077(/* Returns # of additional syncs needed to free barrier)A
532 197 :M
.222(*/)A
90 208 :M
-.192(BarrierSync\(bptr\))A
315 208 :M
.018 .002(/* Waits at a barrier synchronization point)J
532 208 :M
.222(*/)A
90 219 :M
-.173(BarrierWaiting\(bptr\))A
315 219 :M
.049 .005(/* Returns the # of processes waiting at the barrier)J
532 219 :M
.222(*/)A
265 238 :M
f9_12 sf
2.644 .264(FLAG Operations)J
86 229 -1 2 88 227 1 86 227 @a
-1 -2 88 229 1 2 86 227 @b
88 229 -1 2 542 227 1 88 227 @a
542 229 -1 2 544 227 1 542 227 @a
-1 -2 544 229 1 2 542 227 @b
86 243 -1 2 88 241 1 86 241 @a
-1 -2 88 243 1 2 86 241 @b
88 243 -1 2 542 241 1 88 241 @a
542 243 -1 2 544 241 1 542 241 @a
-1 -2 544 243 1 2 542 241 @b
-1 -2 88 241 1 2 86 229 @b
-1 -2 544 241 1 2 542 229 @b
90 258 :M
f7_10 sf
-.128(NewFlag\(fname\) )A
315 258 :M
-.014(/* Creates and returns a pointer to a new flag)A
532 258 :M
.222(*/)A
90 269 :M
-.122(FlagRelease\(fptr\))A
315 269 :M
.096 .01(/* Releases activities waiting at a flag)J
532 269 :M
.222(*/)A
90 280 :M
-.053(FlagSet\(fptr\))A
315 280 :M
.25 .025(/* Sets a flag)J
532 280 :M
.222(*/)A
90 291 :M
-.1(FlagWait\(fptr\))A
315 291 :M
-.016(/* Waits for a flag to be set or released)A
532 291 :M
.222(*/)A
90 302 :M
-.067(FlagWaiting\(fptr\))A
315 302 :M
.132 .013(/* Returns the # of activities in the queue)J
532 302 :M
.222(*/)A
261 321 :M
f9_12 sf
2.806 .281(STVAR Operations)J
86 312 -1 2 88 310 1 86 310 @a
-1 -2 88 312 1 2 86 310 @b
88 312 -1 2 542 310 1 88 310 @a
542 312 -1 2 544 310 1 542 310 @a
-1 -2 544 312 1 2 542 310 @b
86 326 -1 2 88 324 1 86 324 @a
-1 -2 88 326 1 2 86 324 @b
88 326 -1 2 542 324 1 88 324 @a
542 326 -1 2 544 324 1 542 324 @a
-1 -2 544 326 1 2 542 324 @b
-1 -2 88 324 1 2 86 312 @b
-1 -2 544 324 1 2 542 312 @b
90 341 :M
f7_10 sf
-.108(NewFvar\(fvname, x\))A
315 341 :M
-.009(/* Creates and returns a pointer to a new Fvar)A
532 341 :M
.222(*/)A
90 352 :M
-.108(NewIvar\(ivname, i\))A
315 352 :M
-.026(/* Creates and returns a pointer to a new Ivar)A
532 352 :M
.222(*/)A
90 363 :M
.219 .022(Fset\(fvptr, x\) )J
315 363 :M
.183 .018(/* Sets the value of an Fvar)J
532 363 :M
.222(*/)A
90 374 :M
-.086(Fval\(fvptr\))A
315 374 :M
.179 .018(/* Returns th value of an Fvar)J
532 374 :M
.222(*/)A
90 385 :M
.108 .011(Iset\(ivptr, i\))J
315 385 :M
.095 .009(/* Sets the value of an Ivar)J
532 385 :M
.222(*/)A
90 396 :M
-.053(Ival\(ivptr\) )A
315 396 :M
.043 .004(/* Returns the value of an Ivar)J
532 396 :M
.222(*/)A
245 415 :M
f9_12 sf
2.766 .277(CONDITION Operations)J
86 406 -1 2 88 404 1 86 404 @a
-1 -2 88 406 1 2 86 404 @b
88 406 -1 2 542 404 1 88 404 @a
542 406 -1 2 544 404 1 542 404 @a
-1 -2 544 406 1 2 542 404 @b
86 420 -1 2 88 418 1 86 418 @a
-1 -2 88 420 1 2 86 418 @b
88 420 -1 2 542 418 1 88 418 @a
542 420 -1 2 544 418 1 542 418 @a
-1 -2 544 420 1 2 542 418 @b
-1 -2 88 418 1 2 86 406 @b
-1 -2 544 418 1 2 542 406 @b
90 435 :M
f7_10 sf
.161 .016(NewCondition\(cname, exname, sv1, ..., svn, NULL, argptr, argsize\))J
315 446 :M
-.017(/* Creates and returns a pointer to a new condition)A
532 446 :M
.222(*/)A
90 457 :M
-.032(ConditionSetArg\(cptr, aptr, asize\))A
315 457 :M
.139 .014(/* Sets the argument pointer of a condition )J
532 457 :M
.222(*/)A
90 468 :M
-.063(ConditionState\(cptr\))A
315 468 :M
.111 .011(/* Returns the state of a condition)J
532 468 :M
.222(*/)A
90 479 :M
-.091(ConditionWait\(cptr\))A
315 479 :M
.146 .015(/* Waits until a condition holds)J
532 479 :M
.222(*/)A
90 490 :M
-.067(ConditionWaiting\(cptr\))A
315 490 :M
.132 .013(/* Returns the # of activities in the queue)J
532 490 :M
.222(*/)A
247 509 :M
f9_12 sf
2.861 .286(RESOURCE Operations)J
86 500 -1 2 88 498 1 86 498 @a
-1 -2 88 500 1 2 86 498 @b
88 500 -1 2 542 498 1 88 498 @a
542 500 -1 2 544 498 1 542 498 @a
-1 -2 544 500 1 2 542 498 @b
86 514 -1 2 88 512 1 86 512 @a
-1 -2 88 514 1 2 86 512 @b
88 514 -1 2 542 512 1 88 512 @a
542 514 -1 2 544 512 1 542 512 @a
-1 -2 544 514 1 2 542 512 @b
-1 -2 88 512 1 2 86 500 @b
-1 -2 544 512 1 2 542 500 @b
90 529 :M
f7_10 sf
-.1(NewResource\(rname, qdisc, nserv, slice\))A
315 529 :M
-.04(/* Creates and returns a pointer to a new resource)A
532 529 :M
.222(*/)A
90 540 :M
-.119(ResourceServicing\(rptr\))A
315 540 :M
.165 .016(/* Returns the # of activities getting service)J
532 540 :M
.222(*/)A
90 551 :M
-.073(ResourceUse\(rptr, timeinc\))A
315 551 :M
-.055(/* Requests service from a resource )A
532 551 :M
.222(*/)A
90 562 :M
-.125(ResourceWaiting\(rptr\))A
315 562 :M
.032 .003(/* Returns the # of processes in the queue)J
532 562 :M
.222(*/)A
253 581 :M
f9_12 sf
2.594 .259(STATREC Operations)J
86 572 -1 2 88 570 1 86 570 @a
-1 -2 88 572 1 2 86 570 @b
88 572 -1 2 542 570 1 88 570 @a
542 572 -1 2 544 570 1 542 570 @a
-1 -2 544 572 1 2 542 570 @b
86 586 -1 2 88 584 1 86 584 @a
-1 -2 88 586 1 2 86 584 @b
88 586 -1 2 542 584 1 88 584 @a
542 586 -1 2 544 584 1 542 584 @a
-1 -2 544 586 1 2 542 584 @b
-1 -2 88 584 1 2 86 572 @b
-1 -2 544 584 1 2 542 572 @b
90 601 :M
f7_10 sf
.293 .029(NewStatrec\(sname, type, meanflg, histflg, nbins, lowbin, highbin\))J
315 612 :M
-.025(/* Creates and returns a pointer to a new statrec)A
532 612 :M
.222(*/)A
90 623 :M
-.122(StatrecBins\(srptr\))A
315 623 :M
.239 .024(/* Returns the number of bins)J
532 623 :M
.222(*/)A
90 634 :M
-.12(StatrecBinSize\(srptr\))A
315 634 :M
.255 .025(/* Returns the bin size)J
532 634 :M
.222(*/)A
90 645 :M
-.137(StatrecEndInterval\(srptr\) )A
315 645 :M
.133 .013(/* Terminates a sampling interval )J
532 645 :M
.222(*/)A
90 656 :M
-.109(StatrecHighBin\(srptr\))A
315 656 :M
.168 .017(/* Returns the high bin lower bound)J
532 656 :M
.222(*/)A
90 667 :M
.078 .008(StatrecHist\(srptr, i\) )J
315 667 :M
.216 .022(/* Returns the value of the ith histogram element )J
532 667 :M
.222(*/)A
90 678 :M
-.106(StatrecInterval\(srptr\) )A
315 678 :M
.239 .024(/* Returns the sampling interval)J
532 678 :M
.222(*/)A
90 689 :M
-.132(StatrecLowBin\(srptr\))A
315 689 :M
.146 .015(/* Returns the low bin upper bound)J
532 689 :M
.222(*/)A
90 700 :M
-.1(StatrecMaxVal\(srptr\) )A
315 700 :M
.223 .022(/* Returns the maximum sample value)J
532 700 :M
.222(*/)A
90 711 :M
-.147(StatrecMean\(srptr\))A
315 711 :M
.211 .021(/* Returns the mean )J
532 711 :M
.222(*/)A
endp
%%Page: 56 56
%%BeginPageSetup
initializepage
(; page: 56 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.861 .386(Appendix 2)J
542 59 :M
2.658(53)A
90 81 :M
f7_10 sf
-.067(StatrecMinVal\(srptr\) )A
315 81 :M
.301 .03(/* Returns the minimum sample value)J
532 81 :M
.222(*/)A
90 92 :M
-.121(StatrecRate\(srptr\))A
315 92 :M
.187 .019(/* Returns the sampling rate)J
532 92 :M
.222(*/)A
90 103 :M
-.103(StatrecReport\(srptr\))A
315 103 :M
-.082(/* Generates and displays a statrec report)A
532 103 :M
.222(*/)A
90 114 :M
-.108(StatrecReset\(srptr\))A
315 114 :M
.133 .013(/* Resets the statrec )J
532 114 :M
.222(*/)A
90 125 :M
-.081(StatrecSamples\(srptr\))A
315 125 :M
.162 .016(/* Returns the number of samples)J
532 125 :M
.222(*/)A
90 136 :M
-.143(StatrecSdv\(srptr\))A
315 136 :M
-.051(/* Returns the standard deviation )A
532 136 :M
.222(*/)A
90 147 :M
-.062(StatrecSetHistSz\(sz\))A
315 147 :M
.1 .01(/* Set the default histogram size )J
532 147 :M
.222(*/)A
90 158 :M
-.064(StatrecUpdate\(srptr, x, y\))A
315 158 :M
-.064(/* Updates the statrec)A
532 158 :M
.222(*/)A
90 169 :M
-.357(YacRand\(\))A
315 169 :M
-.037(/* Random number generator )A
532 169 :M
.222(*/)A
90 180 :M
-.413(YacSeed\(seed\))A
315 180 :M
-.09(/* Set the seed for yacrand)A
532 180 :M
.222(*/)A
258 199 :M
f9_12 sf
2.444 .244(DRIVER Operations)J
86 190 -1 2 88 188 1 86 188 @a
-1 -2 88 190 1 2 86 188 @b
88 190 -1 2 542 188 1 88 188 @a
542 190 -1 2 544 188 1 542 188 @a
-1 -2 544 190 1 2 542 188 @b
86 204 -1 2 88 202 1 86 202 @a
-1 -2 88 204 1 2 86 202 @b
88 204 -1 2 542 202 1 88 202 @a
542 204 -1 2 544 202 1 542 202 @a
-1 -2 544 204 1 2 542 202 @b
-1 -2 88 202 1 2 86 190 @b
-1 -2 544 202 1 2 542 190 @b
90 219 :M
f7_10 sf
-.158(DriverInterrupt\(retval\))A
315 219 :M
-.034(/* Interrupts the driver and returns retval to the user)A
532 219 :M
.222(*/)A
90 230 :M
-.163(DriverReset\(\))A
315 230 :M
.244 .024(/* Resets the driver \(Sets YS__Simtime to 0\))J
532 230 :M
.222(*/)A
90 241 :M
-.083(DriverRun\(timeinc\))A
315 241 :M
-.004(/* Activates the simulation driver returns a value)A
532 241 :M
.222(*/)A
90 252 :M
.331 .033(EventListCollectStats\(type, meanflg, histflg, nbin, low, high\)   /* Activates automatic stats collection)J
532 252 :M
.222(*/)A
90 263 :M
-.01(EventListResetStats\(\))A
315 263 :M
-.037(/* Resest a statistics record of a queue)A
532 263 :M
.222(*/)A
90 274 :M
.069 .007(EventListSelect\(type, bins, bwidth\))J
315 274 :M
.265 .026(/* Selects the type of event list to use)J
532 274 :M
.222(*/)A
90 285 :M
-.053(EventListSize\(\))A
315 285 :M
.25 .025(/* Returns the event list size)J
532 285 :M
.222(*/)A
90 296 :M
(EventListStatPtr\(type\))S
315 296 :M
.276 .028(/* Returns ptr to evlst's statrec )J
532 296 :M
.222(*/)A
90 307 :M
-.028(GetSimTime\(\))A
315 307 :M
.241 .024(/* Returns the current simulation time)J
532 307 :M
.222(*/)A
endp
%%Page: 57 57
%%BeginPageSetup
initializepage
(; page: 57 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
524 739 :M
f4_12 sf
2.658(54)A
93 86 :M
f9_18 sf
2.193 .219(APPENDIX 3:  ALPHABETICAL OPERATION LIST)J
126 117 :M
f7_10 sf
-.087(ActivityArgSize\(aptr\))A
499 117 :M
(8)S
126 128 :M
-.012(ActivityCollectStats\(aptr\))A
499 128 :M
(8)S
126 139 :M
-.103(ActivityGetArg\(aptr\))A
499 139 :M
(8)S
126 150 :M
-.025(ActivityGetMyPtr\(\))A
499 150 :M
(8)S
126 161 :M
-.047(ActivityGetParPtr\(\))A
499 161 :M
(8)S
126 172 :M
-.064(ActivitySchedCond\(aptr, condptr, blkflg\))A
499 172 :M
(7)S
126 183 :M
-.007(ActivitySchedFlag\(aptr, flgptr, blkflg\))A
499 183 :M
(7)S
126 194 :M
.039 .004(ActivitySchedRes\(aptr, rptr, timeinc, blkflg\))J
499 194 :M
(7)S
126 205 :M
-.019(ActivitySchedSema\(aptr, semptr, blkflg\))A
499 205 :M
(6)S
126 216 :M
-.01(ActivitySchedTime\(aptr, timeinc, blkflg\))A
499 216 :M
(6)S
126 227 :M
-.041(ActivitySetArg\(aptr, argptr, argsize\))A
499 227 :M
(7)S
126 238 :M
-.009(ActivityStatPtr\(aptr\))A
499 238 :M
(9)S
126 249 :M
-.02(ActivityStatRept\(aptr\))A
499 249 :M
(9)S
126 260 :M
-.091(BarrierInit\(bptr, i\))A
494 260 :M
(21)S
126 271 :M
-.367(BarrierNeeded\(bptr\))A
494 271 :M
(21)S
126 282 :M
-.192(BarrierSync\(bptr\))A
494 282 :M
(21)S
126 293 :M
-.173(BarrierWaiting\(bptr\))A
494 293 :M
(22)S
126 304 :M
-.032(ConditionSetArg\(cptr, aptr, asize\))A
494 304 :M
(27)S
126 315 :M
-.063(ConditionState\(cptr\))A
494 315 :M
(27)S
126 326 :M
-.091(ConditionWait\(cptr\))A
494 326 :M
(27)S
126 337 :M
-.067(ConditionWaiting\(cptr\))A
494 337 :M
(27)S
126 348 :M
-.158(DriverInterrupt\(retval\))A
494 348 :M
(39)S
126 359 :M
-.163(DriverReset\(\))A
494 359 :M
(39)S
126 370 :M
-.083(DriverRun\(timeinc\))A
494 370 :M
(39)S
126 381 :M
-.109(EventGetDelFlag\(eptr\))A
494 381 :M
(15)S
126 392 :M
-.101(EventGetState\(\))A
494 392 :M
(16)S
126 403 :M
-.147(EventGetType\(eptr\))A
494 403 :M
(15)S
126 414 :M
.455 .046(EventListCollectStats\(type, meanflg, histflg, nbin, low, high\))J
494 414 :M
(41)S
126 425 :M
-.01(EventListResetStats\(\))A
494 425 :M
(42)S
126 436 :M
.069 .007(EventListSelect\(type, bins, bwidth\))J
494 436 :M
(41)S
126 447 :M
-.053(EventListSize\(\))A
494 447 :M
(41)S
126 458 :M
(EventListStatPtr\(type\))S
494 458 :M
(42)S
126 469 :M
-.127(EventReschedCond\(condptr, stval\))A
494 469 :M
(16)S
126 480 :M
-.058(EventReschedFlag\(flgptr, stval\))A
494 480 :M
(16)S
126 491 :M
-.039(EventReschedRes\(resptr, timeinc, stval\))A
494 491 :M
(16)S
126 502 :M
-.072(EventReschedSema\(semptr, stval\))A
494 502 :M
(16)S
126 513 :M
-.059(EventReschedTime\(timeinc, stval\))A
494 513 :M
(16)S
126 524 :M
-.06(EventSetDelFlag\(\))A
494 524 :M
(16)S
126 535 :M
-.033(EventSetState\(stvat\))A
494 535 :M
(16)S
126 546 :M
-.063(EventSetType\(eptr, etype\))A
494 546 :M
(15)S
126 557 :M
-.122(FlagRelease\(fptr\))A
494 557 :M
(23)S
126 568 :M
-.053(FlagSet\(fptr\))A
494 568 :M
(23)S
126 579 :M
-.1(FlagWait\(fptr\))A
494 579 :M
(23)S
126 590 :M
-.067(FlagWaiting\(fptr\))A
494 590 :M
(23)S
126 601 :M
.107 .011(Fset\(fvptr, x\))J
494 601 :M
(25)S
126 612 :M
-.086(Fval\(fvptr\))A
494 612 :M
(25)S
126 623 :M
-.028(GetSimTime\(\))A
494 623 :M
(40)S
126 634 :M
.108 .011(Iset\(ivptr, i\))J
494 634 :M
(25)S
126 645 :M
-.108(Ival\(ivptr\))A
494 645 :M
(25)S
126 656 :M
-.172(NewBarrier\(bname, i\))A
494 656 :M
(21)S
126 667 :M
.161 .016(NewCondition\(cname, exname, sv1, ..., svn, NULL, argptr, argsize\))J
494 667 :M
(26)S
126 678 :M
-.092(NewEvent\(ename, bodyname, delflg, etype\))A
494 678 :M
(15)S
126 689 :M
-.176(NewFlag\(fname\))A
494 689 :M
(23)S
126 700 :M
-.108(NewFvar\(fvname, x\))A
494 700 :M
(25)S
126 711 :M
-.108(NewIvar\(ivname, i\))A
494 711 :M
(25)S
endp
%%Page: 58 58
%%BeginPageSetup
initializepage
(; page: 58 of 58)setjob
%%EndPageSetup
-31 -31 :T
gS 31 31 552 730 rC
90 59 :M
f4_12 sf
3.861 .386(Appendix 3)J
524 59 :M
2.658(55)A
88 63 -1 1 542 62 1 88 62 @a
126 81 :M
f7_10 sf
-.072(NewProcess\(pname, bodyname, stksz\))A
494 81 :M
(11)S
126 92 :M
-.1(NewResource\(rname, qdisc, nserv, slice\))A
494 92 :M
(29)S
126 103 :M
-.087(NewSemaphore\(sname, i\))A
494 103 :M
(19)S
126 114 :M
.293 .029(NewStatrec\(sname, type, meanflg, histflg, nbins, lowbin, highbin\))J
494 114 :M
(34)S
126 125 :M
-.101(ProcessCheckMsg\(type, sender\))A
494 125 :M
(13)S
126 136 :M
-.103(ProcessDelay\(timeinc\))A
494 136 :M
(11)S
126 147 :M
-.072(ProcessJoin\(\))A
494 147 :M
(12)S
126 158 :M
-.016(ProcessReceiveMsg\(buf, bytes, blkflg, type, sender\))A
494 158 :M
(12)S
126 169 :M
.045 .005(ProcessSendMsg\(dest, buf, bytes, blkflg, type\))J
494 169 :M
(12)S
126 180 :M
-.014(ProcessSetPriority\(procptr, p\))A
494 180 :M
(12)S
126 191 :M
-.014(ProcessSetStkSz\(stksz\))A
494 191 :M
(11)S
126 202 :M
-.109(ProcessSleep\(\))A
494 202 :M
(11)S
126 213 :M
.303 .03(QueueCollectStats\(qptr, type, meanflg, histflg, nbin, low, high\))J
494 213 :M
(32)S
126 224 :M
-.126(QueueResetStats\(qptr\))A
494 224 :M
(32)S
126 235 :M
-.056(QueueStatPtr\(qptr, type\))A
494 235 :M
(32)S
126 246 :M
-.119(ResourceServicing\(rptr\))A
494 246 :M
(29)S
126 257 :M
-.073(ResourceUse\(rptr, timeinc\))A
494 257 :M
(29)S
126 268 :M
-.125(ResourceWaiting\(rptr\))A
494 268 :M
(29)S
126 279 :M
-.17(SemaphoreDecr\(sptr\))A
494 279 :M
(20)S
126 290 :M
-.014(SemaphoreInit\(sptr, i\))A
494 290 :M
(19)S
126 301 :M
-.083(SemaphoreSet\(sptr\))A
494 301 :M
(20)S
126 312 :M
-.059(SemaphoreSignal\(sptr\))A
494 312 :M
(19)S
126 323 :M
-.132(SemaphoreValue\(sptr\))A
494 323 :M
(20)S
126 334 :M
-.115(SemaphoreWait\(sptr\))A
494 334 :M
(20)S
126 345 :M
-.088(SemaphoreWaiting\(sptr\))A
494 345 :M
(20)S
126 356 :M
-.122(StatrecBins\(srptr\))A
494 356 :M
(35)S
126 367 :M
-.12(StatrecBinSize\(srptr\))A
494 367 :M
(35)S
126 378 :M
-.164(StatrecEndInterval\(srptr\))A
494 378 :M
(36)S
126 389 :M
-.109(StatrecHighBin\(srptr\))A
494 389 :M
(35)S
126 400 :M
-.009(StatrecHist\(srptr, i\))A
494 400 :M
(35)S
126 411 :M
-.135(StatrecInterval\(srptr\))A
494 411 :M
(36)S
126 422 :M
-.132(StatrecLowBin\(srptr\))A
494 422 :M
(35)S
126 433 :M
-.132(StatrecMaxVal\(srptr\))A
494 433 :M
(36)S
126 444 :M
-.147(StatrecMean\(srptr\))A
494 444 :M
(36)S
126 455 :M
-.097(StatrecMinVal\(srptr\))A
494 455 :M
(36)S
126 466 :M
-.121(StatrecRate\(srptr\))A
494 466 :M
(36)S
126 477 :M
-.103(StatrecReport\(srptr\))A
494 477 :M
(35)S
126 488 :M
-.108(StatrecReset\(srptr\))A
494 488 :M
(35)S
126 499 :M
-.081(StatrecSamples\(srptr\))A
494 499 :M
(36)S
126 510 :M
-.143(StatrecSdv\(srptr\))A
494 510 :M
(36)S
126 521 :M
-.062(StatrecSetHistSz\(sz\))A
494 521 :M
(34)S
126 532 :M
-.064(StatrecUpdate\(srptr, x, y\))A
494 532 :M
(35)S
126 543 :M
-.357(YacRand\(\))A
494 543 :M
(38)S
126 554 :M
-.413(YacSeed\(seed\))A
494 554 :M
(38)S
endp
%%Trailer
end		% md
%%EOF
